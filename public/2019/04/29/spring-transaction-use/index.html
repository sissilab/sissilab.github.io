<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sissilab.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 数据库事务基础知识在使用Spring开发过程中，我们常会使用到Spring事务管理，它提供了灵活方便的事务管理功能，但这些功能都是基于底层数据库本身的事务处理机制功工作的。因此欲深入了解Spring事务的管理和配置，有必要先了解下数据库基本的事务知识。 1.1. 事务特性（ACID）Spring事务中存在四种特性：原子性、一致性、隔离性和持久性。在这些事务特性中，数据“一致性”为最终目标，其">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring事务用法详解">
<meta property="og:url" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/index.html">
<meta property="og:site_name" content="羊驼之野望">
<meta property="og:description" content="1. 数据库事务基础知识在使用Spring开发过程中，我们常会使用到Spring事务管理，它提供了灵活方便的事务管理功能，但这些功能都是基于底层数据库本身的事务处理机制功工作的。因此欲深入了解Spring事务的管理和配置，有必要先了解下数据库基本的事务知识。 1.1. 事务特性（ACID）Spring事务中存在四种特性：原子性、一致性、隔离性和持久性。在这些事务特性中，数据“一致性”为最终目标，其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/read-uncommitted.png">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/read-committed-1.png">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/read-committed-2.png">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/repeatable-read.png">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/serializable-1.png">
<meta property="og:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/serializable-2.png">
<meta property="article:published_time" content="2019-04-29T14:24:16.000Z">
<meta property="article:modified_time" content="2021-10-17T12:46:59.229Z">
<meta property="article:author" content="Roy">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sissilab.github.io/2019/04/29/spring-transaction-use/read-uncommitted.png">

<link rel="canonical" href="https://sissilab.github.io/2019/04/29/spring-transaction-use/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring事务用法详解 | 羊驼之野望</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">羊驼之野望</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sissilab.github.io/2019/04/29/spring-transaction-use/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dinosaur.jpeg">
      <meta itemprop="name" content="Roy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="羊驼之野望">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring事务用法详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-29 22:24:16" itemprop="dateCreated datePublished" datetime="2019-04-29T22:24:16+08:00">2019-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-17 20:46:59" itemprop="dateModified" datetime="2021-10-17T20:46:59+08:00">2021-10-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Spring框架系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-数据库事务基础知识"><a href="#1-数据库事务基础知识" class="headerlink" title="1. 数据库事务基础知识"></a>1. 数据库事务基础知识</h1><p>在使用Spring开发过程中，我们常会使用到Spring事务管理，它提供了灵活方便的事务管理功能，但这些功能都是基于底层数据库本身的事务处理机制功工作的。因此欲深入了解Spring事务的管理和配置，有必要先了解下数据库基本的事务知识。</p>
<h2 id="1-1-事务特性（ACID）"><a href="#1-1-事务特性（ACID）" class="headerlink" title="1.1. 事务特性（ACID）"></a>1.1. 事务特性（ACID）</h2><p>Spring事务中存在四种特性：原子性、一致性、隔离性和持久性。在这些事务特性中，数据“一致性”为最终目标，其他特性都是为实现这个目标方法和手段。数据库一般采用重执行日志保证原子性、一致性和持久性，采用数据库锁机制保证事务的隔离性。</p>
<span id="more"></span>
<ul>
<li><strong>原子性（Atomicity）</strong>：将一个事务中的多个数据库操作捆绑成一个不可分割的原子单元。即对于一个事务的操作，要么全部执行，要么全部不执行。只有当整个事务的所有操作都执行成功，才会提交，否则即使整个事务中只要有一个操作失败，就算是已执行的操作也都必须都回滚到初始状态。</li>
<li><strong>一致性（Consitency）</strong>：当事务完成时，必须保证所有数据都处于一致状态，即数据不会被破坏。如从A账户转账100元到B账户，无论操作是否成功，A和B的存款总额总是不变的。</li>
<li><strong>隔离性（Isolation）</strong>：在并发操作数据时，不同的事务会有不同的数据操作，且它们的操作不会相互干扰。数据库规定了多种隔离级别，隔离级别越低，并发性越好，干扰越大会导致数据一致性变差；而隔离性越高，并发性越差，数据一致性越好。</li>
<li><strong>持久性（Durability）</strong>：一旦事务成功完成提交后，整个事务的数据都会持久化到数据库中，且结果不受系统错误影响，即使系统崩溃，也可通过某种机制恢复数据。</li>
</ul>
<h2 id="1-2-数据并发问题"><a href="#1-2-数据并发问题" class="headerlink" title="1.2. 数据并发问题"></a>1.2. 数据并发问题</h2><p>数据库中某块数据可能会同时被多个并发事务同时访问，若没有采取必要的隔离措施，可能会导致各种并发问题，破坏数据完整性。这些问题主要如下：</p>
<ul>
<li><strong>脏读（Dirty Read）</strong>：A事务读取到B事务尚未提交的更改数据，并在此基础上操作（B可能回滚）。比如，B事务取款操作会将账户上的余额进行更改且尚未提交，此时A事务查询到B事务尚未提交的账户余额，然后B事务回滚，账号余额恢复到更改之前，而A事务读取到的仍是B事务更改后的金额，若A事务在此基础上做操作，则会导致数据“变脏”。</li>
<li><strong>不可重复读（Unrepeatable Read）</strong>：A事务先后读取同一条记录，在两次读取之间该条记录被B事务<strong>修改</strong>并提交，则会导致A事务两次读取的数据不同。比如，A事务先查询账户余额，在下次读取之前，此时B事务卡在中间修改了账户余额并提交，然后A事务在读取账户余额时会发现两次读取金额不一致。</li>
<li><strong>幻读（Phantom Read）</strong>：A事务先后按相同查询条件去读取数据，在两次读取之间被B事务<strong>插入</strong>了新的满足条件的数据并提交，则会导致A事务两次读取的结果不同。比如，A事务按条件去查询当前账户中已绑定的卡情况，在下次查询之前，此时B事务卡在中间对该账户新增一张卡，然后A事务在按相同条件查询时，会发现多了一张卡。</li>
</ul>
<h2 id="1-3-事务隔离级别"><a href="#1-3-事务隔离级别" class="headerlink" title="1.3. 事务隔离级别"></a>1.3. 事务隔离级别</h2><p>事务隔离级别分为四种，如下：</p>
<ul>
<li><strong>读未提交（Read Uncommitted）</strong>：可以读取到未提交的数据。当一个事务已经写入一行数据但未提交，此时其他事务可以读到这个尚未提交的数据。</li>
<li><strong>读已提交（Read Committed）</strong>：不可以读取到未提交的数据，只能读到已提交的数据。</li>
<li><strong>重复读（Repeatable Read）</strong>：保证多次读取的数据都是一致的。</li>
<li><strong>串读（Serializable）</strong>：最严格的事务隔离级别，不允许事务并行执行，只允许串行执行。事务执行时，如读操作和写操作都会加锁，好似事务就是以串行方式执行。</li>
</ul>
<p>不同事务隔离级别能够解决数据并发问题的能力是不同的，具体对应关系如下所示：</p>
<table><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr><tr><td>Read Uncommitted</td><td>√（允许）</td><td>√</td><td>√</td></tr><tr><td>Read Committed</td><td>×（不允许）</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></table>

<h1 id="2-代码验证简述"><a href="#2-代码验证简述" class="headerlink" title="2. 代码验证简述"></a>2. 代码验证简述</h1><p>下面将以具体代码实例来演示Spring事务中@Transactional的每个参数的使用情况，代码结构主要分为Service和Dao层，由Spring负责依赖注入和注解式事务管理，Dao层由Mybatis实现，分别配置了双数据源<strong>Oracle</strong>和<strong>MySQL</strong>，其中Oracle对应的事务管理器限定符为<strong>oracleTM</strong>，MySql对应的为<strong>mysqlTM</strong>。当使用Spring事务注解@Transactional且未指定value（事务管理器）时，将会以默认的事务管理器来处理（以加载顺序，首先加载的作为默认事务管理器）。</p>
<p>Oracle和MySql分别新增了两张相同的表：<strong>T_SERVER1</strong>和<strong>T_SERVER2</strong>。这两张表的结构完全一致，共有2个字段：<strong>ID</strong>（varchar(32) not null primary key）和<strong>NAME</strong>（varchar(50)）。</p>
<ul>
<li><strong>Bean层</strong>：<br>因为所有表结构都一致，故采用同一个Bean——Server类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get和set方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Dao层</strong>：</li>
</ul>
<p>Dao层代码分为Oracle和MySQL对应的Mapper接口，Oracle对应的Mapper接口（Server1OracleDao接口和Server2OracleDao接口）为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server1 Dao（基于Oracle）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server1OracleDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向T_SERVER1中插入一条新数据，其中主键id为32位sys_guid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into T_SERVER1 values (sys_guid(),#&#123;name&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Server server)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询T_SERVER1中的所有数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from T_SERVER1&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键id，查询T_SERVER1中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Options</span>注解能够设置缓存信息</span></span><br><span class="line"><span class="comment">     * useCache = true，表示会缓存本次查询结果</span></span><br><span class="line"><span class="comment">     * flushCache = Options.FlushCachePolicy.FALSE，表示查询时不刷新缓存</span></span><br><span class="line"><span class="comment">     * timeout = 10000，表示查询结果缓存10000秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Options(useCache = false, flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from T_SERVER1 where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Server <span class="title">getServerById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键id，更新T_SERVER1中的name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update T_SERVER1 set name=#&#123;name&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateServerNameById</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server2 Dao（基于Oracle）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server2OracleDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向T_SERVER2中插入一条新数据，其中主键id为32位sys_guid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into T_SERVER2 values (sys_guid(),#&#123;name&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Server server)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MySQL对应的Mapper接口（Server1MysqlDao接口）为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server2 Dao（基于Oracle）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server2OracleDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向T_SERVER2中插入一条新数据，其中主键id为32位sys_guid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into T_SERVER2 values (sys_guid(),#&#123;name&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Server server)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Service层</strong>：<br>具体Service层代码将视不同情况来分别列举，下面将详述。</li>
</ul>
<h1 id="3-Spring事务-传播行为（propagation）"><a href="#3-Spring事务-传播行为（propagation）" class="headerlink" title="3. Spring事务-传播行为（propagation）"></a>3. Spring事务-传播行为（propagation）</h1><p>Spring事务大多特性都是基于底层数据库的功能来完成的，但是Spring的事务传播行为却是Spring凭借自身框架来实现的功能，它是Spring框架独有的事务增强特性。所谓事务传播行为就是指多个事务方法相互调用时，事务如何在这些方法间传播。Spring提供了七种事务传播行为，下面将详解每一种传播行为。</p>
<table id="propagation"> <tr> <th width="25%">事务传播行为类型</th> <th>说明</th> <tr> <tr> <td>PROPAGATION_REQUIRED</td> <td>表示当前方法必须运行在事务中。若当前没有事务，则新建一个事务，若已经存在于一个事务中，则加入到这个事务中。这是最常见的选择。</td> <tr> <tr> <td>PROPAGATION_REQUIRES_NEW</td> <td>表示当前方法必须运行在它自己的事务中。总是会启动一个新的事务，若当前没有事务，则新建一个事务，若已经存在于一个事务中，则会将当前事务挂起。</td> <tr> <tr> <td>PROPAGATION_NESTED</td> <td>表示当前方法运行于嵌套事务中。若已经存在于一个事务中，则会在嵌套事务中运行（相当于子事务），且子事务不会影响父事务和其他子事务，但是父事务会影响其所有子事务；若当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td> <tr> <tr> <td>PROPAGATION_SUPPORTS</td> <td>表示当前方法不需要事务上下文。如果当前没有事务，就以非事务方式执行，若已经存在于一个事务中，则加入到这个事务中。</td> <tr> <tr> <td>PROPAGATION_NOT_SUPPORTED</td> <td>表示当前方法不应该运行在事务中。总是以非事务方式运行，若已经存在于一个事务中，则会将当前事务挂起。</td> <tr> <tr> <td>PROPAGATION_MANDATORY</td> <td>表示当前方法必须在事务中运行。总是想以事务方式运行，若已经存在于一个事务中，则加入到这个事务中，若当前没有事务，则会抛出异常。</td> <tr> <tr> <td>PROPAGATION_NEVER</td> <td>表示当前方法不应该运行于事务上下文中。总是不想以事务方式运行，若已经存在于一个事务中，则会抛出异常，若当前没有事务，则以非事务方式运行。</td> <tr> </table>

<p>验证Spring事务传播行为的Service层接口和实现类、验证Spring事务传播的两个Service类、以及测试方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring事务传播行为 测试接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">iTransactionPropagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体接口方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring事务传播行为 测试实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionPropagationImpl</span> <span class="keyword">implements</span> <span class="title">iTransactionPropagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server1 service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> iServer1Service server1Service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server2 service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> iServer2Service server2Service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server1 dao（基于Oracle）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server1OracleDao server1OracleDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server2 dao（基于Oracle）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server2OracleDao server2OracleDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体接口实现方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server1接口（验证Spring事务传播）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体接口实现方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server1实现类（验证Spring事务传播）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server1 Dao（基于Oracle）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server1OracleDao server1OracleDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体接口实现方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server2接口（验证Spring事务传播）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体接口实现方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server2实现类（验证Spring事务传播）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server2 Dao（基于Oracle）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server2OracleDao server2OracleDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体接口实现方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类：Spring事务传播行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;classpath*:/META-INF/spring/applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionPropagationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring事务传播行为测试类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> iTransactionPropagation transactionPropagation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体测试方法，下面将分情况描述...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里针对的是<mark>不同service类之间方法的调用</mark>。</p>
<h2 id="3-1-PROPAGATION-REQUIRED"><a href="#3-1-PROPAGATION-REQUIRED" class="headerlink" title="3.1. PROPAGATION_REQUIRED"></a>3.1. PROPAGATION_REQUIRED</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.REQUIRED属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *有事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequired</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequired</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=REQUIRED），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequiredException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.REQUIRED修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-1-1-外围方法未开启事务"><a href="#3-1-1-外围方法未开启事务" class="headerlink" title="3.1.1. 外围方法未开启事务"></a>3.1.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法未开启事务，Propagation.REQUIRED修饰的内部方法会启动一个新的事务，且开启的事务相互独立、互不干扰。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1方法和server2方法各自在自己的事务中独立运行，外围方法的异常不影响内部方法的插入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_required_required</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入，“服务2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1方法和server2方法各自在自己的事务中独立运行，</span></span><br><span class="line"><span class="comment"> * 其中server2方法抛出异常只会回滚server2中操作，而server1方法不受影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_required_requiredException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequiredException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-外围方法开启事务"><a href="#3-1-2-外围方法开启事务" class="headerlink" title="3.1.2. 外围方法开启事务"></a>3.1.2. 外围方法开启事务</h3><p>当外围方法开启事务，三种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法开启事务，Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，并与外围方法属于同一事务，只要一个方法回滚，整个事务均回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务，</span></span><br><span class="line"><span class="comment"> * 外围方法抛出异常，外围方法和内部方法均回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_required_required</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务，</span></span><br><span class="line"><span class="comment"> * server2方法的内部事务抛出异常，外围方法感知异常致使整体事务回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_required_requiredException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequiredException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法3：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常，并被捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务，</span></span><br><span class="line"><span class="comment"> * server2方法的内部事务抛出异常并在外围方法中捕获，即使server2方法被catch不被外围方法感知，整个事务依然回滚。</span></span><br><span class="line"><span class="comment"> * （同一事务中所有方法只要有一个感知到异常，整体事务都回滚）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_required_requiredExceptionTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server2Service.saveRequiredException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-PROPAGATION-REQUIRES-NEW"><a href="#3-2-PROPAGATION-REQUIRES-NEW" class="headerlink" title="3.2. PROPAGATION_REQUIRES_NEW"></a>3.2. PROPAGATION_REQUIRES_NEW</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.REQUIRES_NEW属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequiresNew</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequiresNew</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=REQUIRES_NEW），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveRequiresNewException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.REQUIRES_NEW修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-2-1-外围方法未开启事务"><a href="#3-2-1-外围方法未开启事务" class="headerlink" title="3.2.1. 外围方法未开启事务"></a>3.2.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法未开启事务，Propagation.REQUIRES_NEW修饰的内部方法会启动一个新的事务，且开启的事务相互独立、互不干扰。</makr></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2分别会启动自己的事务独立运行，即使外围方法抛出异常，也不会影响内部方法（不会回滚）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_requiresNew_requiresNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入，“服务2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2分别会启动自己的事务独立运行，其中server2方法中抛出异常会回滚，但不会影响server1的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_requiresNew_requiresNewException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveRequiresNewException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-外围方法开启事务"><a href="#3-2-2-外围方法开启事务" class="headerlink" title="3.2.2. 外围方法开启事务"></a>3.2.2. 外围方法开启事务</h3><p>当外围方法开启事务，三种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法开启事务，Propagation.REQUIRES_NEW修饰的内部方法仍会启动一个新的事务，且与外围方法事务和内部方法事务之间均相互独立、互不干扰。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入，“服务2.1”和“服务2.2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务，</span></span><br><span class="line"><span class="comment"> * 当外围方法抛出异常时，与外围方法是同一事务的server1会回滚，但server2.1和server2.2不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_required_requiresNew_requiresNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>)); <span class="comment">// 与外围方法是同一事务，会回滚</span></span><br><span class="line">    server2Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.1&quot;</span>)); <span class="comment">// 新建事务，不会回滚</span></span><br><span class="line">    server2Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.2&quot;</span>)); <span class="comment">// 新建事务，不会回滚</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入，“服务2.1”插入，“服务2.2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务，</span></span><br><span class="line"><span class="comment"> * 当server2.2抛出异常时，server2.2的事务会回滚，外围方法也会感知到异常，server1也会回滚，</span></span><br><span class="line"><span class="comment"> * 而server2.1在新建的独立事务中，不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_required_requiresNew_requiresNewException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>)); <span class="comment">// 与外围方法是同一事务，会回滚</span></span><br><span class="line">    server2Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.1&quot;</span>)); <span class="comment">// 新建事务，不会回滚</span></span><br><span class="line">    server2Service.saveRequiresNewException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.2&quot;</span>)); <span class="comment">// 新建事务，会回滚</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法3：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW）</span></span><br><span class="line"><span class="comment"> * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常，并捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入，“服务2.1”插入，“服务2.2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务，</span></span><br><span class="line"><span class="comment"> * 当server2.2抛出异常时，server2.2的事务会回滚，外围方法catch住了这个异常，故server1不会回滚，</span></span><br><span class="line"><span class="comment"> * server2.1在新建的独立事务中，也不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_required_requiresNew_requiresNewExceptionTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>)); <span class="comment">// 与外围方法是同一事务，不会回滚</span></span><br><span class="line">    server2Service.saveRequiresNew(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.1&quot;</span>)); <span class="comment">// 新建事务，不会回滚</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server2Service.saveRequiresNewException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2.2&quot;</span>)); <span class="comment">// 新建事务，会回滚</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-PROPAGATION-NESTED"><a href="#3-3-PROPAGATION-NESTED" class="headerlink" title="3.3. PROPAGATION_NESTED"></a>3.3. PROPAGATION_NESTED</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.NESTED属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNested</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *有事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNested</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *有事务（传播行为=NESTED），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNestedException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NESTED修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-3-1-外围方法未开启事务"><a href="#3-3-1-外围方法未开启事务" class="headerlink" title="3.3.1. 外围方法未开启事务"></a>3.3.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得：<mark>外围方法未开启事务，Propagation.PROPAGATION_NESTED和Propagation.PROPAGATION_REQUIRED作用相同，修饰内部的方法分别会启动自己的事务，且启动的事务相互独立、互不干扰。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2分别在自己的事务中独立运行，外围方法的异常不影响内部方法的插入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_Nested_Nested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入，“服务2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2分别在自己的事务中独立运行，</span></span><br><span class="line"><span class="comment"> * 其中server2中抛出异常，其事务会回滚，但是不会影响server1的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_Nested_NestedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNestedException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-外围方法开启事务"><a href="#3-3-2-外围方法开启事务" class="headerlink" title="3.3.2. 外围方法开启事务"></a>3.3.2. 外围方法开启事务</h3><p>当外围方法开启事务，三种验证方法及结果情况如下所示。<br>由此可得：<mark>外围方法开启事务，Propagation.PROPAGATION_NESTED修饰的内部方法属于外围事务的子事务，外围父事务回滚，则其所有子事务都回滚，若其中一个子事务回滚，则不会影响外围父事务和其他内部事务。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，内部事务是外围事务的子事务，外围方法抛出异常，导致其子事务（server1和server2）也需要回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_Nested_Nested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，内部事务是外围事务的子事务，内部方法server2中抛出异常，使得server2会回滚，</span></span><br><span class="line"><span class="comment"> * 而外围方法可以感知到异常，会使其所有子事务都回滚，故而server1也会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Nested_NestedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNestedException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法3：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NESTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常，并捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入，“服务2”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，内部事务是外围事务的子事务，内部方法server2中抛出异常，使得server2会回滚，</span></span><br><span class="line"><span class="comment"> * 而外围方法由于catch住了异常，无法感知到异常，故而server1不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Nested_NestedExceptionTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNested(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server2Service.saveNestedException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>【<strong>注1</strong>】：Spring事务传播行为中PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED的区别？</mark><br>REQUIRED是默认的事务传播行为。</p>
<p>REQUIRED、REQUIRES_NEW和NESTED这3种传播行为在修饰内部方法时，若外围方法无事务，都会新建一个新事务，且事务之间相互独立、互不干扰。</p>
<p>当外围方法有事务情况，REQUIRED和NESTED修饰的内部方法都属于外围方法事务，若外围方法抛出异常，都会回滚。但是，REQUIRED是加入外围事务，与外围方法属于同一事务，不管谁抛出异常，都会回滚；而NESTED是属于外围事务的子事务，有单独的保存点（savepoint），被NESTED修饰的内部方法（子事务）抛出异常会回滚，但不会影响到外围方法事务。</p>
<p>无论外围方法是否有事务，REQUIRES_NEW和NESTED修饰的内部方法抛出异常都不会影响到外围方法事务。当外围方法有事务情况，由于NESTED是嵌套事务，其修饰的内部方法为子事务，一旦外围方法事务回滚，会影响其所有子事务都回滚；而由于REQUIRES_NEW修饰的内部方法为启动一个新事务来实现的，故而内部事务和外围事务相互独立，外围事务回滚并不会影响到内部事务。</p>
<h2 id="3-4-PROPAGATION-SUPPORTS"><a href="#3-4-PROPAGATION-SUPPORTS" class="headerlink" title="3.4. PROPAGATION_SUPPORTS"></a>3.4. PROPAGATION_SUPPORTS</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.SUPPORTS属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSupports</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSupports</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=SUPPORTS），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSupportsException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.SUPPORTS修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-4-1-外围方法未开启事务"><a href="#3-4-1-外围方法未开启事务" class="headerlink" title="3.4.1. 外围方法未开启事务"></a>3.4.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法未开启事务，Propagation.SUPPORTS修饰的内部方法以非事务方式运行，即使出现异常，也不会回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2以非事务方式运行，外围方法抛出的异常不会影响server1和server2。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_Supports_Supports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常，并捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2以非事务方式运行，即使server2中抛出异常，server1和server2都不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_Supports_SupportsException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveSupportsException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-外围方法未开启事务"><a href="#3-4-2-外围方法未开启事务" class="headerlink" title="3.4.2. 外围方法未开启事务"></a>3.4.2. 外围方法未开启事务</h3><p>当外围方法开启事务，三种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法开启事务，Propagation.SUPPORTS修饰的内部方法会加入外围事务，任一事务回滚，整个事务均会回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1和server2加入外围事务，当外围方法抛出异常，server1和server都会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_Supports_Supports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1和server2加入外围事务，其中server2中抛出异常，影响所有事务都回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Supports_SupportsException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveSupportsException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法3：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常，并捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1和server2加入外围事务，其中server2抛出异常，虽然在外围方法中catch住了，所有事务仍会都回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Supports_SupportsExceptionTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveSupports(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server2Service.saveSupportsException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-PROPAGATION-NOT-SUPPORTED"><a href="#3-5-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="3.5. PROPAGATION_NOT_SUPPORTED"></a>3.5. PROPAGATION_NOT_SUPPORTED</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.NOT_SUPPORTED属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NOT_SUPPORTED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNotSupported</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NOT_SUPPORTED）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNotSupported</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NOT_SUPPORTED），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNotSupportedException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NOT_SUPPORTED修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-5-1-外围方法未开启事务"><a href="#3-5-1-外围方法未开启事务" class="headerlink" title="3.5.1. 外围方法未开启事务"></a>3.5.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法未开启事务，Propagation.NOT_SUPPORTED修饰的内部方法以非事务方式运行，不会被影响而回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=SUPPORTS）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1以非事务方式运行，即使外围方法抛出异常，也不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_notSuppored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNotSupported(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NOT_SUPPORTED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED），且抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，被NOT_SUPPORTED修饰的server1和server2，即使server2中抛出异常，server1和server2都会以非事务方式运行，不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_notSuppored_notSupporedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNotSupported(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNotSupportedException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-外围方法开启事务"><a href="#3-5-2-外围方法开启事务" class="headerlink" title="3.5.2. 外围方法开启事务"></a>3.5.2. 外围方法开启事务</h3><p>当外围方法开启事务，两种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法开启事务，Propagation.NOT_SUPPORTED修饰的内部方法以非事务方式运行，不会被影响而回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入，“服务2”插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1加入外围事务，server2以非事务方式运行，</span></span><br><span class="line"><span class="comment"> * 当外围方法抛出异常时，server1会回滚，server2不受影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_required_notSuppored</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>)); <span class="comment">// 与外围事务同事务，会回滚</span></span><br><span class="line">    server2Service.saveNotSupported(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>)); <span class="comment">// 非事务，不会回滚</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=REQUIRED）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入，“服务2”插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1加入外围事务，server2以非事务方式运行，</span></span><br><span class="line"><span class="comment"> * 其中server2中抛出异常，但server2不会回滚，而外围方法会感知到异常，影响server1会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_required_notSupporedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveRequired(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>)); <span class="comment">// 与外围事务同事务，会回滚</span></span><br><span class="line">    server2Service.saveNotSupportedException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>)); <span class="comment">// 非事务，不会回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-PROPAGATION-MANDATORY"><a href="#3-6-PROPAGATION-MANDATORY" class="headerlink" title="3.6. PROPAGATION_MANDATORY"></a>3.6. PROPAGATION_MANDATORY</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.MANDATORY属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMandatory</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMandatory</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=MANDATORY），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMandatoryException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.MANDATORY修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-6-1-外围方法未开启事务"><a href="#3-6-1-外围方法未开启事务" class="headerlink" title="3.6.1. 外围方法未开启事务"></a>3.6.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，一种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法未开启事务，当外围方法调用Propagation.MANDATORY修饰的内部方法会抛出异常。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，外围方法调用server1时，会抛出异常</span></span><br><span class="line"><span class="comment"> * （org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_Mandatory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveMandatory(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-外围方法开启事务"><a href="#3-6-2-外围方法开启事务" class="headerlink" title="3.6.2. 外围方法开启事务"></a>3.6.2. 外围方法开启事务</h3><p>当外围方法开启事务，三种验证方法及结果情况如下所示。<br>由此可得出：<mark>外围方法开启事务，Propagation.MANDATORY修饰的内部方法会加入外围事务，任一事务回滚，整个事务均会回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，内部方法事务加入外围事务，外围方法抛出异常，server1和server2均会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionException_Mandatory_Mandatory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveMandatory(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveMandatory(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=MANDATORY），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，内部方法事务加入外围事务，其中server2中抛出异常，server2回滚，外围方法感知到异常，也会导致server1回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Mandatory_MandatoryException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveMandatory(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveMandatoryException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法3：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=MANDATORY）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=MANDATORY），最后抛出异常，并捕获</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，server1和server2加入外围事务，其中server2中抛出异常，虽然在外围方法中catch住了，所有事务仍会都回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_Mandatory_MandatoryExceptionTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveMandatory(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server2Service.saveMandatoryException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-PROPAGATION-NEVER"><a href="#3-7-PROPAGATION-NEVER" class="headerlink" title="3.7. PROPAGATION_NEVER"></a>3.7. PROPAGATION_NEVER</h2><p>为Server1Service和Server2Service的相应方法加上Propagation.NEVER属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer1Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NEVER）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNever</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server2ServiceImpl</span> <span class="keyword">implements</span> <span class="title">iServer2Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NEVER）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNever</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有事务（传播行为=NEVER），且存在异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNeverException</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">        server2OracleDao.save(server);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NEVER修饰的内部方法，以验证事务传播特性。</p>
<h3 id="3-7-1-外围方法未开启事务"><a href="#3-7-1-外围方法未开启事务" class="headerlink" title="3.7.1. 外围方法未开启事务"></a>3.7.1. 外围方法未开启事务</h3><p>当外围方法未开启事务，两种验证方法及结果情况如下所示。<br>由此可得：<mark>外围方法未开启事务，当外围方法调用Propagation.NEVER修饰的内部方法，内部方法会以非事务方式运行，不会被影响而回滚。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务，最后抛出异常</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NEVER）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1以非事务方式运行，即使外围方法抛出异常，也不受影响，不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactionException_never</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNever(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**验证方法2：</span></span><br><span class="line"><span class="comment"> * 外围方法：未开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NEVER）</span></span><br><span class="line"><span class="comment"> * -&gt;server2方法：开启事务（传播行为=NEVER），最后抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment"> * 外围方法未开启事务，server1和server2均以非事务方式运行，即使server2中抛出异常，也不受影响，均不会回滚。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransaction_never_neverException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNever(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    server2Service.saveNeverException(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2-外围方法开启事务"><a href="#3-7-2-外围方法开启事务" class="headerlink" title="3.7.2. 外围方法开启事务"></a>3.7.2. 外围方法开启事务</h3><p>当外围方法开启事务，一种验证方法及结果情况如下所示。<br>由此可得：<mark>外围方法开启事务，当外围方法调用Propagation.NEVER修饰的内部方法，会抛出异常。</mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**验证方法1：</span></span><br><span class="line"><span class="comment"> * 外围方法：开启事务</span></span><br><span class="line"><span class="comment"> * -&gt;server1方法：开启事务（传播行为=NEVER）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：“服务1”未插入。</span></span><br><span class="line"><span class="comment"> * 外围方法开启事务，当调用被NEVER修饰的server1内部方法时，会抛出异常</span></span><br><span class="line"><span class="comment"> * （org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#x27;never&#x27;）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transaction_never</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server1Service.saveNever(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Spring事务-隔离级别（isolation）"><a href="#4-Spring事务-隔离级别（isolation）" class="headerlink" title="4. Spring事务-隔离级别（isolation）"></a>4. Spring事务-隔离级别（isolation）</h1><p>当多个事务同时操作同一数据库的记录时，这就会涉及并发控制和数据库隔离性问题了，其中隔离级别是数据库的事务特性ACID的一部分。Spring事务定义的隔离级别共有5个：DEFAULT、READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ和SERIALIZABLE。下面将详述每种隔离级别。</p>
<h2 id="4-1-DEFAULT"><a href="#4-1-DEFAULT" class="headerlink" title="4.1. DEFAULT"></a>4.1. DEFAULT</h2><p>Spring默认隔离级别，使用后端数据库默认的隔离级别。<br>大多数数据库默认的事务隔离级别是Read committed，比如Sql Server、Oracle，MySQL的默认隔离级别是Repeatable read。</p>
<h2 id="4-2-READ-UNCOMMITTED"><a href="#4-2-READ-UNCOMMITTED" class="headerlink" title="4.2. READ_UNCOMMITTED"></a>4.2. READ_UNCOMMITTED</h2><p><strong>读未提交</strong>：允许脏读，也就是<mark>一个事务可以读取到其他事务未提交的记录</mark>。隔离性最弱，并发性最高。<br>见下图（MySQL环境），<font color='green'>事务B更新数据后且尚未提交，事务A能读取到事务B未提交的数据“server1”，但是之后事务B回滚，此时事务A再次读取到的数据为之前的旧数据“服务1”，因此事务A读取到的数据就不是有效的</font>，这种情况称为脏读。除了脏读，还会存在不可重复读和幻读的问题。</p>
<img src="/2019/04/29/spring-transaction-use/read-uncommitted.png" class="" title="Spring事务-Read Uncommitted">
<p>需要注意的是，当我们基于Oracle数据库来通过Spring设置隔离级别为READ_UNCOMMITTED和REPEATABLE_READ时会有问题，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**READ_UNCOMMITTED（读未提交）[Oracle]：A事务可以读取到B事务未提交的事务记录（B事务可能回滚）。</span></span><br><span class="line"><span class="comment"> * 隔离性最低、并发性最好。存在脏读、不可重复读和幻读问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Oracle支持READ COMMITTED和SERIALIZABLE这两种事务隔离级别，默认为READ COMMITTED。</span></span><br><span class="line"><span class="comment"> * 若以Isolation.READ_UNCOMMITTED或Isolation.REPEATABLE_READ访问，则会抛出如下异常：</span></span><br><span class="line"><span class="comment"> * org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction;</span></span><br><span class="line"><span class="comment"> * nested exception is java.sql.SQLException: 仅 READ_COMMITTED 和 SERIALIZABLE 是有效的事务处理级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(value = &quot;oracleTM&quot;, isolation = Isolation.READ_UNCOMMITTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readUncommittedByOracle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始 READ_UNCOMMITTED[Oracle]...&quot;</span>);</span><br><span class="line">    List&lt;Server&gt; serverList = serverOracleDao.getAllServers();</span><br><span class="line">    System.out.println(<span class="string">&quot;serverList: &quot;</span> + serverList);</span><br><span class="line">    System.out.println(<span class="string">&quot;结束 READ_UNCOMMITTED[MySQL]...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用基于Oracle且设置隔离级别为READ_UNCOMMITTED和REPEATABLE_READ时，会抛出异常：org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is java.sql.SQLException: 仅 READ_COMMITTED 和 SERIALIZABLE 是有效的事务处理级。<br>这是因为，<u>Oracle不支持READ_UNCOMMITTED和REPEATABLE_READ这两种事务隔离级别，支持READ_COMMITTED和SERIALIZABLE</u>，默认隔离级别为READ_COMMITTED。</p>
<h2 id="4-3-READ-COMMITTED"><a href="#4-3-READ-COMMITTED" class="headerlink" title="4.3. READ_COMMITTED"></a>4.3. READ_COMMITTED</h2><p><strong>读已提交</strong>：<mark>一个事务只能读取到已经提交的记录</mark>，不能读取到未提交的记录。因此，脏读问题不会再出现，但可能出现其他问题。READ_COMMITTED解决了脏读问题。<br>见下图（MySQL环境），<font color='green'>事务B更新数据后且未提交，此时事务A读取到的是旧数据，接着事务B提交后，事务A再次读取到的是新数据，两次读取到的数据不一致</font>，这种情况称为不可重复读。除了不可重复读问题，还存在幻读问题。</p>
<img src="/2019/04/29/spring-transaction-use/read-committed-1.png" class="" title="Spring事务-Read Committed">

<p>下面事务执行过程中，<font color='green'>事务A设置为Read Committed并开始事务，当事务A查询某个id时，事务B可以直接更新指定id而无需等待，说明查询操作不会加锁；当事务A更新指定id时，事务B会出现等待，直至事务A提交后才会执行更新操作，说明更新操作会加锁</font>。</p>
<img src="/2019/04/29/spring-transaction-use/read-committed-2.png" class="" title="Spring事务-Read Committed-锁">

<h2 id="4-4-REPEATABLE-READ"><a href="#4-4-REPEATABLE-READ" class="headerlink" title="4.4. REPEATABLE_READ"></a>4.4. REPEATABLE_READ</h2><p><strong>重复读</strong>：<mark>一个事务可以多次从数据库读取某条记录，而且多次读取的那条记录都是一致的</mark>。REPEATABLE_READ解决了脏读和不可重复读问题。<br>见下图（MySQL环境），<font color='green'>在事务A前两次查询之间，事务B更新和插入数据并自动提交，发现事务A两次读取数据一致</font>。这是因为，MySQl的存储引擎InnoDB通过多版本并发控制（MVCC，Multi-Version Concurrency Control）机制解决了该问题，实现了同一事务中多次读取某条记录（即使这条记录被其他事务更新或插入）的结果始终保持一致。但是，<font color='green'>当事务A尚未提交，并插入id为’333’的数时，提示插入失败显示主键重复，说明该记录已存在。当事务A提交后，在以相同条件进行查询，可以发现事务B更新和插入后的数据</font>。</p>
<img src="/2019/04/29/spring-transaction-use/repeatable-read.png" class="" title="Spring事务-Repeatable-Read">

<h2 id="4-5-SERIALIZABLE"><a href="#4-5-SERIALIZABLE" class="headerlink" title="4.5. SERIALIZABLE"></a>4.5. SERIALIZABLE</h2><p><strong>串读</strong>：<mark>事务执行时，会在涉及数据上加锁，强制事务排序，使之不会相互冲突</mark>。隔离性最强，并发性最弱。<br>见下图（MySQL环境），<font color='green'>事务A隔离级别设置为Serializable，并查询表中id为’111’的数据，该操作将会锁住被读取行数据，当事务B尝试去更新表中id为’111’的数据时，会一直等待，直至事务A提交，才会执行更新操作；而当事务B去更新id为’222’的数据时，不受影响，直接更新完，即不同行锁不会相互影响</font>。</p>
<img src="/2019/04/29/spring-transaction-use/serializable-1.png" class="" title="Spring事务-Serializable-行锁">

<p>下面串行事务中，<font color='green'>事务A隔离级别设置为Serializable，并查询整个表的数据，将会对整个表加锁，因此当事务B进行更新操作或者插入操作时，都将进入等待，直至事务A提交，才能开始进行操作</font>。</p>
<img src="/2019/04/29/spring-transaction-use/serializable-2.png" class="" title="Spring事务-Serializable-表锁">

<h1 id="5-Spring事务-超时（timeout）"><a href="#5-Spring事务-超时（timeout）" class="headerlink" title="5. Spring事务-超时（timeout）"></a>5. Spring事务-超时（timeout）</h1><p>Spring事务参数timeout为超时时间，默认值为-1，指没有超时限制。<mark>如果超过设置的超时时间，事务还没有完成的话，则会抛出事务超时异常TransactionTimedOutException，并回滚事务</mark>。<br>在下面的事务超时测试示例中，事务超时时间设置为2秒。<br>在saveServer1_saveServer2_sleep()方法中，sleep操作（为了模拟超时场景）放在两个保存操作之后，在执行完两个保存之后出现超时情况，此时由结果可知，两个保存操作均插入。<br>在saveServer1_sleep_saveServer2()方法中，sleep操作放在两个保存操作之间，在执行完第一个保存之后出现超时情况，此时由结果可知，两个保存操作均未插入。<br><strong>结论</strong>：<mark>Spring事务超时 = 事务开始时到最后一个Statement创建时时间 + 最后一个Statement的执行时超时时间（即其queryTimeout）</mark>。如下代码中，事务超时区间为事务开始到第二个保存操作，之后的操作超时将不会引起事务回滚。因此，当设置了超时参数，需要考虑到<font color='green'>重要的操作不要放到最后执行</font>，或是<font color='green'>在操作最后加上一个无关紧要的Statement操作</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring超时测试 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutImpl</span> <span class="keyword">implements</span> <span class="title">iTimeout</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server1OracleDao server1Dao;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server2OracleDao server2Dao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间设置为2（单位为秒，默认为-1，表示无超时无限制）。</span></span><br><span class="line"><span class="comment">     * 执行顺序为：saveServer1 --&gt; saveServer2 --&gt; sleep 5 秒</span></span><br><span class="line"><span class="comment">     * 结果：“服务1”和“服务2”均插入。</span></span><br><span class="line"><span class="comment">     * 事务没有因为超时而回滚（事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。）</span></span><br><span class="line"><span class="comment">     * 原因：Spring事务超时 = 事务开始时到最后一个Statement创建时时间 + 最后一个Statement的执行时超时时间（即其queryTimeout）。所以在在执行Statement之外的超时无法进行事务回滚。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(timeout = 2, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServer1_saveServer2_sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始保存 Server1...&quot;</span>);</span><br><span class="line">        server1Dao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;结束保存 Server1...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始保存 Server2...&quot;</span>);</span><br><span class="line">        server2Dao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;结束保存 Server2...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始等待...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间设置为2（单位为秒）。</span></span><br><span class="line"><span class="comment">     * 执行顺序为：saveServer1 --&gt; sleep 5 秒 --&gt; saveServer2</span></span><br><span class="line"><span class="comment">     * 结果：“服务1”和“服务2”均未插入。</span></span><br><span class="line"><span class="comment">     * 事务成功回滚，抛出事务超时异常org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Thu Apr 25 11:39:06 CST 2019</span></span><br><span class="line"><span class="comment">     * 总结：重要的操作不要放到最后一个Statement后面，尽量放到Statement中间，或是在操作后加上一个无关紧要的Statement操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(timeout = 2, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServer1_sleep_saveServer2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始保存 Server1...&quot;</span>);</span><br><span class="line">        server1Dao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;结束保存 Server1...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始等待...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n开始保存 Server2...&quot;</span>);</span><br><span class="line">        server2Dao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;结束保存 Server2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-Spring事务-只读（readOnly）"><a href="#6-Spring事务-只读（readOnly）" class="headerlink" title="6. Spring事务-只读（readOnly）"></a>6. Spring事务-只读（readOnly）</h1><p>Spring的只读事务readOnly参数设置为true时，<font color='green'>说明当前方法没有增改删的操作，Spring会优化这个方法，即使用了一个只读的connection，效率会高很多</font>。<br><strong>建议使用场景为</strong>：当前方法查询量较大，且确保不会出现增改删情况；防止当前方法会出现增改删操作。<br>在如下示例中可知，设置为只读事务，<font color='green'>基于MySQl执行保存操作会抛出异常，而基于Oracle执行保存操作则成功插入，不受readOnly参数影响</font>。<br>Spring的只读事务<u>并不是一个强制指令，它相当于一个提醒，提醒数据库当前事务为只读事务，不包含增改删操作，那么数据库则可能会根据情况进行一些特定的优化</u>，如不考虑加相应的锁，减轻数据库的资源消耗。当然，并不是所有的数据库都支持只读事务，默认情况下在设置只读参数后，Oracle依旧可以进行增改删操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring事务只读测试 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadOnlyImpl</span> <span class="keyword">implements</span> <span class="title">iReadOnly</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server1 dao（基于Oracle）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server1OracleDao server1OracleDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Server1 dao（基于MySQL）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Server1MysqlDao server1MysqlDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于MySQL - 只读</span></span><br><span class="line"><span class="comment">     * 执行保存操作失败，会报错。</span></span><br><span class="line"><span class="comment">     * ### Error updating database.  Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(value = &quot;mysqlTM&quot;, readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServerByMysql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server1MysqlDao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于Oracle - 只读</span></span><br><span class="line"><span class="comment">     * 执行保存操作成功，不受只读设置影响。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(value = &quot;oracleTM&quot;, readOnly = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServerByOracle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server1OracleDao.save(<span class="keyword">new</span> Server(<span class="string">&quot;服务1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）"><a href="#7-Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）" class="headerlink" title="7. Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）"></a>7. Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）</h1><p>Spring事务的回滚规则，如rollbackFor、rollbackForClassName、noRollbackFor和noRollbackForClassName，指定了遇到什么异常进行回滚，或者遇到什么异常不回滚。</p>
<ul>
<li><strong>rollbackFor</strong>：设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。（默认为RuntimeException）。</li>
<li><strong>rollbackForClassName</strong>：设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。</li>
<li><strong>noRollbackFor</strong>：设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。</li>
<li><strong>noRollbackForClassName</strong>：设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。</li>
</ul>
<p>这些回滚规则均可指定单一异常类或者多个异常类，如：</p>
<ul>
<li><strong>rollbackFor和noRollbackFor指定单一异常类</strong>形式为：<code>@Transactional(rollbackFor=RuntimeException.class)</code>，<code>@Transactional(noRollbackFor=RuntimeException.class)</code></li>
<li><strong>rollbackFor和noRollbackFor指定多个异常类</strong>形式为：<code>@Transactional(rollbackFor=&#123;RuntimeException.class, Exception.class&#125;)</code>，<code>@Transactional(noRollbackFor=&#123;RuntimeException.class, Exception.class&#125;)</code>   </li>
<li><strong>rollbackForClassName和noRollbackForClassName指单一异常类名称</strong>形式为：<code>@Transactional(rollbackForClassName=&quot;RuntimeException&quot;)</code>，<code>@Transactional(noRollbackFor=&quot;RuntimeException&quot;)</code>   </li>
<li><strong>rollbackForClassName和noRollbackForClassName指多个异常类名称</strong>形式为：<code>@Transactional(rollbackForClassName=&#123;&quot;RuntimeException&quot;, &quot;Exception&quot;&#125;)</code>，<code>@Transactional(noRollbackFor=&#123;&quot;RuntimeException&quot;, &quot;Exception&quot;&#125;)</code>   </li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><font size=2>
[1] 陈雄华. Spring 3.x 企业应用开发实战[M]. 电子工业出版社. 2012.<br>
[2] Spring事务传播行为详解. https://segmentfault.com/a/1190000013341344#articleHeader14.<br>
[3] Spring事务隔离级别简介及实例解析. https://www.jb51.net/article/134466.htm.<br>
[4] MySQL的四种事务隔离级别. https://www.cnblogs.com/huanongying/p/7021555.html.<br>
[5] Spring官方文档-事务. https://docs.spring.io/spring/docs/5.0.9.RELEASE/spring-framework-reference/data-access.html#transaction.<br>
[6] Spring事务采坑 —— timeout. https://blog.csdn.net/qq_18860653/article/details/79907984.<br>
[7] Spring 使用注解方式进行事务管理. https://www.cnblogs.com/younggun/p/3193800.html.
</font>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"># 事务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/18/collection-linkedlist-sourcecode/" rel="prev" title="java.util集合（collection）之LinkedList源码分析（jdk1.8）">
      <i class="fa fa-chevron-left"></i> java.util集合（collection）之LinkedList源码分析（jdk1.8）
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/23/qrcode-scan-login/" rel="next" title="三种方式实现扫码登录">
      三种方式实现扫码登录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">1. 数据库事务基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="nav-text">1.1. 事务特性（ACID）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">1.2. 数据并发问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">1.3. 事务隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81%E7%AE%80%E8%BF%B0"><span class="nav-text">2. 代码验证简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Spring%E4%BA%8B%E5%8A%A1-%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%88propagation%EF%BC%89"><span class="nav-text">3. Spring事务-传播行为（propagation）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-PROPAGATION-REQUIRED"><span class="nav-text">3.1. PROPAGATION_REQUIRED</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.1.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.1.2. 外围方法开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-PROPAGATION-REQUIRES-NEW"><span class="nav-text">3.2. PROPAGATION_REQUIRES_NEW</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.2.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.2.2. 外围方法开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-PROPAGATION-NESTED"><span class="nav-text">3.3. PROPAGATION_NESTED</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.3.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.3.2. 外围方法开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-PROPAGATION-SUPPORTS"><span class="nav-text">3.4. PROPAGATION_SUPPORTS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.4.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.4.2. 外围方法未开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-PROPAGATION-NOT-SUPPORTED"><span class="nav-text">3.5. PROPAGATION_NOT_SUPPORTED</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.5.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.5.2. 外围方法开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-PROPAGATION-MANDATORY"><span class="nav-text">3.6. PROPAGATION_MANDATORY</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.6.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.6.2. 外围方法开启事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-PROPAGATION-NEVER"><span class="nav-text">3.7. PROPAGATION_NEVER</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E6%9C%AA%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.7.1. 外围方法未开启事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-%E5%A4%96%E5%9B%B4%E6%96%B9%E6%B3%95%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="nav-text">3.7.2. 外围方法开启事务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Spring%E4%BA%8B%E5%8A%A1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88isolation%EF%BC%89"><span class="nav-text">4. Spring事务-隔离级别（isolation）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-DEFAULT"><span class="nav-text">4.1. DEFAULT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-READ-UNCOMMITTED"><span class="nav-text">4.2. READ_UNCOMMITTED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-READ-COMMITTED"><span class="nav-text">4.3. READ_COMMITTED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-REPEATABLE-READ"><span class="nav-text">4.4. REPEATABLE_READ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-SERIALIZABLE"><span class="nav-text">4.5. SERIALIZABLE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Spring%E4%BA%8B%E5%8A%A1-%E8%B6%85%E6%97%B6%EF%BC%88timeout%EF%BC%89"><span class="nav-text">5. Spring事务-超时（timeout）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Spring%E4%BA%8B%E5%8A%A1-%E5%8F%AA%E8%AF%BB%EF%BC%88readOnly%EF%BC%89"><span class="nav-text">6. Spring事务-只读（readOnly）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Spring%E4%BA%8B%E5%8A%A1-%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99%EF%BC%88rollbackFor%E3%80%81rollbackForClassName%E3%80%81noRollbackFor%E3%80%81noRollbackForClassName%EF%BC%89"><span class="nav-text">7. Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Roy"
      src="/images/dinosaur.jpeg">
  <p class="site-author-name" itemprop="name">Roy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
