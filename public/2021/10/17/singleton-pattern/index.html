<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sissilab.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="0. 简介单例模式属于创建型模式，在系统整个生命周期内只存在一个实例，它保证个类仅有一个实例，并提供一个访问它的全局访问点。 核心步骤：  构造方法私有化； 在本类中创建本类的实例； 在本类中提供给外部获取实例的方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="单例模式">
<meta property="og:url" content="https://sissilab.github.io/2021/10/17/singleton-pattern/index.html">
<meta property="og:site_name" content="羊驼之野望">
<meta property="og:description" content="0. 简介单例模式属于创建型模式，在系统整个生命周期内只存在一个实例，它保证个类仅有一个实例，并提供一个访问它的全局访问点。 核心步骤：  构造方法私有化； 在本类中创建本类的实例； 在本类中提供给外部获取实例的方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sissilab.github.io/2021/10/17/singleton-pattern/new_bytecode.excalidraw.png">
<meta property="article:published_time" content="2021-10-17T14:59:50.000Z">
<meta property="article:modified_time" content="2021-10-17T15:15:13.328Z">
<meta property="article:author" content="Roy">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sissilab.github.io/2021/10/17/singleton-pattern/new_bytecode.excalidraw.png">

<link rel="canonical" href="https://sissilab.github.io/2021/10/17/singleton-pattern/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>单例模式 | 羊驼之野望</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">羊驼之野望</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sissilab.github.io/2021/10/17/singleton-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dinosaur.jpeg">
      <meta itemprop="name" content="Roy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="羊驼之野望">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          单例模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-17 22:59:50 / 修改时间：23:15:13" itemprop="dateCreated datePublished" datetime="2021-10-17T22:59:50+08:00">2021-10-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>单例模式属于创建型模式，在系统整个生命周期内只存在一个实例，它保证个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>构造方法私有化；</li>
<li>在本类中创建本类的实例；</li>
<li>在本类中提供给外部获取实例的方式。<span id="more"></span></li>
</ol>
<p><strong>特点：</strong></p>
<ol>
<li>单例类只能有一个实例；</li>
<li>单例类必须自行创建自己的唯一实例；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>单例类可保证内存里只有一个实例，避免了频繁创建和销毁实例，从而可减少内存的开销；</li>
<li>避免对共享资源的多重占用。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>扩展问题，单例模式一般没有接口和抽象层，；</li>
<li>不适用于变化的对象，若同一类型对象要在不同用例场景发生变化，易引起数据错误；</li>
<li>单例模式的功能一般写在一个类中，若功能设计不合理，易违背单一职责原则。</li>
</ol>
<p><strong>适用场景：</strong></p>
<ol>
<li>需频繁实例化和销毁的对象；</li>
<li>创建对象时耗时过多、资源消耗过多，且经常用到的对象，如  I/O 与数据库的连接等；</li>
<li>有状态的工具类对象。</li>
</ol>
<p><strong>几种单例模式的对比：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
<th>可用性</th>
</tr>
</thead>
<tbody><tr>
<td>懒汉式-线程不安全</td>
<td>具有懒加载特性</td>
<td>不支持多线程，只支持单线程环境</td>
<td>不可用</td>
</tr>
<tr>
<td>懒汉式-synchronized方法</td>
<td>解决了“懒汉式-线程不安全”的线程不安全问题</td>
<td>效率低，每个线程想获取类实例时，都需要进行同步</td>
<td>不推荐</td>
</tr>
<tr>
<td>懒汉式-延迟加锁</td>
<td>意图解决“懒汉式-synchronized方法”低效问题</td>
<td>未能完全达到线程同步效果</td>
<td>不可用</td>
</tr>
<tr>
<td>懒汉式-无volatile双重检查</td>
<td>意图引入Double-Check来解决“懒汉式-延迟加锁”线程不同步问题</td>
<td>未能完全达到线程同步效果，因为存在指令重排</td>
<td>不推荐</td>
</tr>
<tr>
<td><mark>懒汉式-volatile双重检查</mark></td>
<td>Double-Check + volatile 保证延迟加载+线程安全（防止重排），且效率较高</td>
<td></td>
<td>推荐</td>
</tr>
<tr>
<td>饿汉式</td>
<td>写法简单，保证线程安全（在类装载时完成实例化）</td>
<td>无延迟加载效果，若自始至终未使用该实例，则会存在内存浪费</td>
<td>可用</td>
</tr>
<tr>
<td><mark>静态内部类</mark></td>
<td>写法简单，相较于“饿汉式”，在一定程度上利用静态内部类特性延迟了初始化</td>
<td></td>
<td>推荐</td>
</tr>
<tr>
<td><mark>枚举型</mark></td>
<td>最佳方法，更简洁，自动支持序列化机制，并且能防止反射攻击</td>
<td></td>
<td>MVP</td>
</tr>
</tbody></table>
<h1 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1. 懒汉式"></a>1. 懒汉式</h1><p>懒汉式（懒加载）指单例实例在第一次被使用时才创建和初始化，延迟加载。</p>
<h2 id="1-1-懒汉式-线程不安全（不可用）"><a href="#1-1-懒汉式-线程不安全（不可用）" class="headerlink" title="1.1. 懒汉式 - 线程不安全（不可用）"></a>1.1. 懒汉式 - 线程不安全（不可用）</h2><p>此种懒汉式单例类在单线程下正常，但在多线程在就会破坏单例，产生不能实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 私有构造函数，限制用户自己创建实例</span></span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟多线程下获取单例非都同一实例情况，增加模拟复现概率</span></span><br><span class="line"> 				TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line"> 			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"> 			&#125;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"> 		&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证代码：</strong></p>
<ul>
<li><p>单线程情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程：lazySingleton1 和 lazySingleton2 为同一个实例  </span></span><br><span class="line">LazySingleton lazySingleton1 = LazySingleton.getInstance();  </span><br><span class="line">LazySingleton lazySingleton2 = LazySingleton.getInstance();  </span><br><span class="line">System.out.println(lazySingleton1 == lazySingleton2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>多线程情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多线程：lazySingleton1 和 lazySingleton2 有几率非同一个实例</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LazySingleton lazySingleton1 = LazySingleton.getInstance();</span><br><span class="line"> System.out.println(lazySingleton1);</span><br><span class="line">&#125;).start(); <span class="comment">// com.xixi.design_pattern.singleton.LazySingleton@1c015d7a</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LazySingleton lazySingleton2 = LazySingleton.getInstance();</span><br><span class="line"> System.out.println(lazySingleton2);</span><br><span class="line">&#125;).start(); <span class="comment">// com.xixi.design_pattern.singleton.LazySingleton@75461a67</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-懒汉式-synchronized-方法（不推荐使用）"><a href="#1-2-懒汉式-synchronized-方法（不推荐使用）" class="headerlink" title="1.2. 懒汉式 - synchronized 方法（不推荐使用）"></a>1.2. 懒汉式 - synchronized 方法（不推荐使用）</h2><p>“1.1. 懒汉式 - 线程不安全”不支持多线程情况，可简单粗暴地在 getInstance() 方法上加锁synchronized 。这种方式虽然可解决线程不安全情况，但由于是在静态方法上加锁，实际上是对该类对象加锁（类锁），效率太低。当每次线程想通过 getInstance() 方法来获取该单例类的实例时，都会加锁，十分影响性能。其实，该方法只需执行一次实例化即可，后面再次请求时，直接返回已实例化的对象即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 私有构造函数，限制用户自己创建实例</span></span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟多线程下获取单例非都同一实例情况，增加模拟复现概率</span></span><br><span class="line"> 				TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line"> 			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"> 			&#125;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"> 		&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-懒汉式-延迟加锁（不可用）"><a href="#1-3-懒汉式-延迟加锁（不可用）" class="headerlink" title="1.3. 懒汉式 - 延迟加锁（不可用）"></a>1.3. 懒汉式 - 延迟加锁（不可用）</h2><p>在“1.2. 懒汉式 - synchronized 方法”基础进行改进，只在第一次加锁，然后在临界区内进行实例化，后面判断 instance 非空时，会直接返回该单例类的实例对象。</p>
<p>但是，在多线程环境下，依旧会存在线程安全问题，如下 线程T1和T2会产生2个不同的对象：<br>T1：刚进临界区，还没完成实例化 –&gt; T2：由于T1还未实例化，此时 instance 为空，还会进入 if 块内 –&gt; T1完成实例化 –&gt; T2完成实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 私有构造函数，限制用户自己创建实例</span></span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">			<span class="comment">// T2：由于T1还未实例化，此时 instance 为空，还会进来</span></span><br><span class="line">			<span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">				<span class="comment">// T1：刚进临界区，还没完成实例化</span></span><br><span class="line">            	instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-懒汉式-无-volatile-双重检查（不推荐使用）"><a href="#1-4-懒汉式-无-volatile-双重检查（不推荐使用）" class="headerlink" title="1.4. 懒汉式 - 无 volatile 双重检查（不推荐使用）"></a>1.4. 懒汉式 - 无 volatile 双重检查（不推荐使用）</h2><p>无volatile双重检查的懒汉式， 由于 instance 属性没有被 volatile 修饰，还是会因为指定重排导致错误。</p>
<p>当 new 一个对象时（如 <code>instance = new LazySingleton();</code>），实际上内部涉及主要的3步有：1. 开辟空间 –&gt; 2. 初始化 –&gt; 3. 引用赋值。</p>
<p>当这3步发生指定重排时，如 1. 开辟空间 –&gt; 3. 引用赋值 –&gt; 2. 初始化，此时就有可能导致线程安全问题：<br>T1：进入临界区，准备 new –&gt; T1：开辟空间 –&gt; T1：引用赋值（由于尚未完成初始化，此时 instance 虽然已指向新开辟的堆空间，但仍为空） –&gt; T2：由于 instance 为空（T1尚未完成初始化），进入 if 块中 –&gt; T1：完成初始化，退出临界区 –&gt; T2：进入临界区，又产生了一个新对象，此时已破坏单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 私有构造函数，限制用户自己创建实例</span></span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// T2：直接返回，而实际 T1 还没完成初始化，返回可导致空指针  </span></span><br><span class="line"> 			<span class="keyword">synchronized</span> (LazySingleton.class) &#123;  </span><br><span class="line">        		<span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;  </span><br><span class="line">            		instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line"> 					<span class="comment">// 字节码层：1、开辟空间 2、初始化 3、引用赋值  </span></span><br><span class="line"> 					<span class="comment">// ==&gt; 实际 JIT / CPU，可能发生指定重排：1、开辟空间 3、引用赋值（T1） 2、初始化  </span></span><br><span class="line"> 				&#125;  </span><br><span class="line">    		&#125;  </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对刚描述的，new 一个对象居然涉及这么多步骤，接下来就从 Java 字节码层面去理解 new 一个对象，先写一个简单的创建对象的测试代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javap -v Test.class  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Test test = <span class="keyword">new</span> Test();  </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译 Test.java 生成 Test.class，若是使用 IDEA，可在该类界面选择 Build –&gt; Recompile ‘Test.java’，亦可通过 <code>javac Test.java</code> 来编译生成 Test.class。</p>
<p> 生成 class 文件后，进入 Test.class 所在目录，通过 <code>javap -v Test.class</code> 反编译 class 字节码文件，可反解析当前类的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息。得到如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Classfile /usr/local/Projects/mine/xixi-lab/target/classes/com/xixi/design_pattern/singleton/Test.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">8</span>-<span class="number">28</span>; size <span class="number">487</span> bytes <span class="comment">// 最后修改时间、文件大小</span></span><br><span class="line">  MD5 checksum be5006130e49c813e079bd8238d8da27 <span class="comment">// MD5值</span></span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xixi</span>.<span class="title">design_pattern</span>.<span class="title">singleton</span>.<span class="title">Test</span> // 类的全限定名</span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52 // <span class="title">Java</span>版本主版本号 52对应1.8</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span> // 访问修饰符</span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>: // 常量池信息</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">21</span>            <span class="comment">// com/xixi/design_pattern/singleton/Test</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">20</span>         <span class="comment">// com/xixi/design_pattern/singleton/Test.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Utf8               Code</span><br><span class="line">   #<span class="number">8</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">9</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               Lcom/xixi/design_pattern/singleton/Test;</span><br><span class="line">  #<span class="number">12</span> = Utf8               main</span><br><span class="line">  #<span class="number">13</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">14</span> = Utf8               args</span><br><span class="line">  #<span class="number">15</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">16</span> = Utf8               test</span><br><span class="line">  #<span class="number">17</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               com/xixi/design_pattern/singleton/Test</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.xixi.design_pattern.singleton.Test();  <span class="comment">// JVM 自动生成的默认无参构造函数</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/xixi/design_pattern/singleton/Test;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; <span class="comment">// main 函数</span></span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 0, 3, 4， 7: Test test = new Test();</span></span><br><span class="line">         <span class="comment">// new: 在堆内存中开辟一块空间 -&gt; 将该引用压至操作数栈顶</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>   <span class="comment">// class com/xixi/design_pattern/singleton/Test</span></span><br><span class="line">         <span class="comment">// dup: 复制栈顶的引用值 -&gt; 将复制的引用值压至栈顶 （复制原因：因为后续 invokespecial 会消耗一个引用）</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="comment">// invokespecial: 调用构造函数对刚开辟的堆空间进行初始化，并消耗一个引用</span></span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>   <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="comment">// astore_1: 弹出栈顶引用 -&gt; 将该引用赋给局部变量表中编号为1位置的元素，即 test （赋值）</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable: <span class="comment">// 描述java源代码行号与字节码行号之间的对应关系</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable: <span class="comment">// 方法的局部变量描述</span></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>       <span class="number">1</span>     <span class="number">1</span>  test   Lcom/xixi/design_pattern/singleton/Test;</span><br><span class="line">    MethodParameters: <span class="comment">// 参数名</span></span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然只是简单的几行代码，但是反解析后的内容超多，重点关注 Code 区中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>   <span class="comment">// class com/xixi/design_pattern/singleton/Test</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span>   <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: astore_1</span><br></pre></td></tr></table></figure>

<p>具体过程如下图所示：</p>
<img src="/2021/10/17/singleton-pattern/new_bytecode.excalidraw.png" class="" title="new_bytecode.excalidraw">
<p>其中，为什么需要 dup 指令来辅助栈顶元素，是因为下一步 invokespecial 需要执行默认构造函数，会从栈顶弹出引用。若无 dup 来复制栈顶，则会导致 invokespecial 后，栈顶为空，就会丢失刚创建的对象了。</p>
<p>这些也就是 new 不是原子操作的解释，new 在 Java 代码层面虽然只是一句代码，但反映到字节码层面却是4句指令操作。由于指定重排的存在，会导致 new 内部的3个步骤发生重排，在多线程环境下，上面单例模式代即会存在问题。故而，给 instance 属性加上 volatile，以防止重排。</p>
<!-- 字节码的详细分析，可参加：[字节码详解](字节码详解.md) -->

<h2 id="1-5-懒汉式-volatile-双重检查（推荐使用）"><a href="#1-5-懒汉式-volatile-双重检查（推荐使用）" class="headerlink" title="1.5. 懒汉式 - volatile 双重检查（推荐使用）"></a>1.5. 懒汉式 - volatile 双重检查（推荐使用）</h2><p>双重检查（Double Check）是最推荐的懒汉式单例，既能保证线程安全，又可实现延迟加载，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// volatile: 防止重排</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 私有构造函数，限制用户自己创建实例</span></span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line"> 			<span class="keyword">synchronized</span> (LazySingleton.class) &#123;  </span><br><span class="line">        		<span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;  </span><br><span class="line">            		instance = <span class="keyword">new</span> LazySingleton();  </span><br><span class="line"> 				&#125;  </span><br><span class="line">    		&#125;  </span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-饿汉式"><a href="#2-饿汉式" class="headerlink" title="2. 饿汉式"></a>2. 饿汉式</h1><p>饿汉式在类加载时就完成初始化了，基于类加载机制来保证单例，没有加锁，从而执行效率更高。但由于在类装载时就实例化，没有延迟加载的优势，若没用到该实例，就会实例化个寂寞，浪费资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式是借助 JVM 的类加载机制，来保证实例的唯一性，因为初始化只会执行一次，且 JVM 会以同步的形式来完成类的加载过程。</p>
<p>类的加载过程：1. 加载二进制数据到内存中，生成对应 Class 数据结构 –&gt; 2. 连接（验证 –&gt; 准备（给类中静态成员变量赋默认值） –&gt; 解析） –&gt; 3. 初始化（给类中静态变量赋初值） –&gt; 4. 使用 –&gt; 5. 卸载</p>
<p>instance 作为静态成员变量，它的实例化发生在类加载的初始化阶段，该阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，该方法由编译器自动收集类中所有 static 变量和 static 块，由此，<code>private static HungrySingleton instance = new HungrySingleton();</code> 也会在这个方法中。而 JVM 会保证一个类的 <code>&lt;clinit&gt;()</code> 在多线程环境下加锁同步，从而保证线程安全。</p>
<!-- 类加载机制的具体原理，可参见：[类加载机制](类加载机制.md) -->

<h1 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h1><p>静态内部类式单例模式本质上也是利用类的加载机制来保证安全，由于其特性，能保证在实际使用时，才会触发类的初始化，也是一种延迟加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton instance = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用到这里，才会导致 InstanceHolder.instance 的初始化</span></span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-反射攻击静态内部类"><a href="#3-1-反射攻击静态内部类" class="headerlink" title="3.1. 反射攻击静态内部类"></a>3.1. 反射攻击静态内部类</h2><p>当通过反射来获取类对象时，与通过静态方法 <code>getInstance()</code> 获取对象对比，可以发现非同意对象，从而破坏单例。</p>
<p>针对该情况，可在私有构造函数中判断 instance  是否为空，若非空情况，则抛出异常，防止反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xixi.design_pattern.singleton.attack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionAttackStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反射攻击  静态内部类型：</span></span><br><span class="line"><span class="comment">     * 通过反射会拿到新的对象，破坏单例</span></span><br><span class="line"><span class="comment">     * 可在私有构造函数中判断instance非空情况时抛出异常，防止反射攻击</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InstantiationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        Constructor&lt;StaticInnerClassSingleton&gt; declaredConstructor = StaticInnerClassSingleton.class.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 拿到权限</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// reflectInstance：通过构造器来创建对象，拿到 StaticInnerClassSingleton 类对象</span></span><br><span class="line">        StaticInnerClassSingleton reflectInstance = declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// instance：直接通过静态方法拿到对象</span></span><br><span class="line">        StaticInnerClassSingleton instance = StaticInnerClassSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较通过反射拿到的对象和类静态方法拿到的对象是否为同一个 --&gt; false</span></span><br><span class="line">        System.out.println(reflectInstance == instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类型 单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton instance = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击：饿汉/静态内部类 可通过该方式来阻止（懒汉无法防止）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != StaticInnerClassSingleton.InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;This Singleton class has been instantiated.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-序列化攻击静态内部类"><a href="#3-2-序列化攻击静态内部类" class="headerlink" title="3.2. 序列化攻击静态内部类"></a>3.2. 序列化攻击静态内部类</h2><p>当对单例类进行序列化和反序列化时，对应类需实现 Serializable。先对单例类进行序列化，生成序列化后文件 –&gt; 在读取该序列化文件，通过反序列化，拿到该单例类的对象 –&gt; 反序列化后的实例与单例类原实例对象 instance 非同一个，从而破坏单例。如下为实现 Serializable 的静态内部类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类 单例模式：实现序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton instance = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != StaticInnerClassSingleton.InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;This Singleton class has been instantiated.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>序列化和反序列化的测试代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xixi.design_pattern.singleton.attack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化攻击 静态内部类：</span></span><br><span class="line"><span class="comment"> * 序列化影响单例情况：对单例对象 instance 先序列化，再反序列化后，拿到的 testSerializableInstance，不是同一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableAttackEnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        StaticInnerClassSingleton instance = StaticInnerClassSingleton.getInstance();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        serialize(instance);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        deserialize(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(StaticInnerClassSingleton instance)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;TestSerializable&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化：不会调用构造函数，从字节流中读取数据进行初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(StaticInnerClassSingleton instance)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;TestSerializable&quot;</span>));</span><br><span class="line">        StaticInnerClassSingleton testSerializableInstance = ((StaticInnerClassSingleton) objectInputStream.readObject());</span><br><span class="line">        System.out.println(instance == testSerializableInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之所以上面反序列化生成了一个新的对象，是因为序列化有它自己的一套机制，它读取字节流数据，并不会调用构造函数。针对非枚举型单例，要想实现可序列化，需加上版本号 <code>private static final long serialVersionUID = -1L;</code>，还需要实现方法 <code>readResolve()</code>，并返回该类实例。这样就可以拿到同一个对象了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类 单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若序列化时未加版本号 serialVersionUID，会根据当前类数据自动生成一个版本号，当反序列化时，亦会自动生成一个版本号，若2个版本号不对应（反序列化前修改类内容），则会报如下错：</span></span><br><span class="line">    <span class="comment">// java.io.InvalidClassException: local class incompatible: stream classdesc serialVersionUID = -6193354024038071874, local class serialVersionUID = 3430229600994946531</span></span><br><span class="line">    <span class="comment">// 指定一个版本号 serialVersionUID 即可解决该问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton instance = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != StaticInnerClassSingleton.InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;This Singleton class has been instantiated.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于非枚举型单例模式在面对序列化攻击时，必须实现readResolve方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInnerClassSingleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析下反序列化的源码，<code>objectInputStream.readObject()</code> –&gt; <code>readObject(Object.class)</code> –&gt; <code>Object obj = readObject0(type, false);</code> –&gt; 在 case-when 的 TC_OBJECT：<code>readOrdinaryObject(unshared)</code>。</p>
<p><code>readOrdinaryObject(unshared)</code> 的重点代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// hasReadResolveMethod：判断当前类是否有readResolve()方法</span></span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用当前类的readResolve()方法</span></span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// Filter the replacement object</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasReadResolveMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="comment">// readResolveMethod非空，即说明当前类有readResolve()方法</span></span><br><span class="line">    <span class="keyword">return</span> (readResolveMethod != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当类前的readResolve()方法赋给readResolveMethod</span></span><br><span class="line">    readResolveMethod = getInheritableMethod(cl, <span class="string">&quot;readResolve&quot;</span>, <span class="keyword">null</span>, Object.class);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-枚举型"><a href="#4-枚举型" class="headerlink" title="4. 枚举型"></a>4. 枚举型</h1><p>枚举型可说是实现单例模式中最佳方式，它不仅可利用类加载机制保证线程安全，还能防止反序列化重建对象，同时能避免反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;  </span><br><span class="line">    instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己所需的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析下枚举型的字节码，编译 EnumSingleton.java 生成 class 后，执行 <code>javap -v -p EnumSingleton.class</code> 来生成字节码文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">Classfile /usr/local/Projects/mine/xixi-lab/target/classes/com/xixi/design_pattern/EnumSingleton.class</span><br><span class="line">  Last modified 2021-8-29; size 1137 bytes</span><br><span class="line">  MD5 checksum 93c6f65a75ff755cbcb6a388b366df6a</span><br><span class="line">  Compiled from &quot;EnumSingleton.java&quot;</span><br><span class="line">// enum 本质是一个 final class，继承了 java.lang.Enum&lt;com.xixi.design_pattern.EnumSingleton&gt;</span><br><span class="line">final class com.xixi.design_pattern.EnumSingleton extends java.lang.Enum&lt;com.xixi.design_pattern.EnumSingleton&gt;</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_FINAL, ACC_SUPER, ACC_ENUM</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Fieldref           #4.#37         // com/xixi/design_pattern/EnumSingleton.$VALUES:[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">   #2 = Methodref          #38.#39        // &quot;[Lcom/xixi/design_pattern/EnumSingleton;&quot;.clone:()Ljava/lang/Object;</span><br><span class="line">   #3 = Class              #14            // &quot;[Lcom/xixi/design_pattern/EnumSingleton;&quot;</span><br><span class="line">   #4 = Class              #40            // com/xixi/design_pattern/EnumSingleton</span><br><span class="line">   #5 = Methodref          #10.#41        // java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">   #6 = Methodref          #10.#42        // java/lang/Enum.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">   #7 = String             #11            // instance</span><br><span class="line">   #8 = Methodref          #4.#42         // com/xixi/design_pattern/EnumSingleton.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">   #9 = Fieldref           #4.#43         // com/xixi/design_pattern/EnumSingleton.instance:Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #10 = Class              #44            // java/lang/Enum</span><br><span class="line">  #11 = Utf8               instance</span><br><span class="line">  #12 = Utf8               Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #13 = Utf8               $VALUES</span><br><span class="line">  #14 = Utf8               [Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #15 = Utf8               values</span><br><span class="line">  #16 = Utf8               ()[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #17 = Utf8               Code</span><br><span class="line">  #18 = Utf8               LineNumberTable</span><br><span class="line">  #19 = Utf8               valueOf</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #21 = Utf8               LocalVariableTable</span><br><span class="line">  #22 = Utf8               name</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               MethodParameters</span><br><span class="line">  #25 = Utf8               &lt;init&gt;</span><br><span class="line">  #26 = Utf8               (Ljava/lang/String;I)V</span><br><span class="line">  #27 = Utf8               this</span><br><span class="line">  #28 = Utf8               $enum$name</span><br><span class="line">  #29 = Utf8               $enum$ordinal</span><br><span class="line">  #30 = Utf8               Signature</span><br><span class="line">  #31 = Utf8               ()V</span><br><span class="line">  #32 = Utf8               anyMethod</span><br><span class="line">  #33 = Utf8               &lt;clinit&gt;</span><br><span class="line">  #34 = Utf8               Ljava/lang/Enum&lt;Lcom/xixi/design_pattern/EnumSingleton;&gt;;</span><br><span class="line">  #35 = Utf8               SourceFile</span><br><span class="line">  #36 = Utf8               EnumSingleton.java</span><br><span class="line">  #37 = NameAndType        #13:#14        // $VALUES:[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #38 = Class              #14            // &quot;[Lcom/xixi/design_pattern/EnumSingleton;&quot;</span><br><span class="line">  #39 = NameAndType        #45:#46        // clone:()Ljava/lang/Object;</span><br><span class="line">  #40 = Utf8               com/xixi/design_pattern/EnumSingleton</span><br><span class="line">  #41 = NameAndType        #19:#47        // valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">  #42 = NameAndType        #25:#26        // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">  #43 = NameAndType        #11:#12        // instance:Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">  #44 = Utf8               java/lang/Enum</span><br><span class="line">  #45 = Utf8               clone</span><br><span class="line">  #46 = Utf8               ()Ljava/lang/Object;</span><br><span class="line">  #47 = Utf8               (Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">&#123;</span><br><span class="line">  // instance 为一个 static final 的属性</span><br><span class="line">  public static final com.xixi.design_pattern.EnumSingleton instance;</span><br><span class="line">    descriptor: Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM</span><br><span class="line"></span><br><span class="line">  private static final com.xixi.design_pattern.EnumSingleton[] $VALUES;</span><br><span class="line">    descriptor: [Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  // values() 由编译器自动生成，用来返回定义的枚举量的数组</span><br><span class="line">  public static com.xixi.design_pattern.EnumSingleton[] values();</span><br><span class="line">    descriptor: ()[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: getstatic     #1                  // Field $VALUES:[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">         3: invokevirtual #2                  // Method &quot;[Lcom/xixi/design_pattern/EnumSingleton;&quot;.clone:()Ljava/lang/Object;</span><br><span class="line">         6: checkcast     #3                  // class &quot;[Lcom/xixi/design_pattern/EnumSingleton;&quot;</span><br><span class="line">         9: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public static com.xixi.design_pattern.EnumSingleton valueOf(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: ldc           #4                  // class com/xixi/design_pattern/EnumSingleton</span><br><span class="line">         2: aload_0</span><br><span class="line">         3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">         6: checkcast     #4                  // class com/xixi/design_pattern/EnumSingleton</span><br><span class="line">         9: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  name   Ljava/lang/String;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      name                           mandated</span><br><span class="line">    </span><br><span class="line">  // 自动生成的私有构造函数</span><br><span class="line">  private com.xixi.design_pattern.EnumSingleton();</span><br><span class="line">    descriptor: (Ljava/lang/String;I)V // 参数：String, int；返回：void</span><br><span class="line">    flags: ACC_PRIVATE // 私有的</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=3</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: iload_2</span><br><span class="line">         3: invokespecial #6                  // Method java/lang/Enum.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">         6: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  this   Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      $enum$name                     synthetic</span><br><span class="line">      $enum$ordinal                  synthetic</span><br><span class="line">    Signature: #31                          // ()V</span><br><span class="line"></span><br><span class="line">  public void anyMethod();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line"></span><br><span class="line">  // 静态代码块</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=4, locals=0, args_size=0</span><br><span class="line">         // new: 在堆中开辟空间，并返回引用压入栈顶</span><br><span class="line">         0: new           #4                  // class com/xixi/design_pattern/EnumSingleton</span><br><span class="line">         // dup: 复制栈顶元素</span><br><span class="line">         3: dup</span><br><span class="line">         // ldc: 将String instance压入栈顶</span><br><span class="line">         4: ldc           #7                  // String instance</span><br><span class="line">         // iconst_0: 将常量int压入栈顶</span><br><span class="line">         6: iconst_0</span><br><span class="line">         // invokespecial：调用构造函数进行初始化 EnumSingleton(String, int)</span><br><span class="line">         7: invokespecial #8                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span><br><span class="line">         // putstatic: 将栈顶元素赋给instance</span><br><span class="line">        10: putstatic     #9                  // Field instance:Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">        13: iconst_1</span><br><span class="line">        14: anewarray     #4                  // class com/xixi/design_pattern/EnumSingleton</span><br><span class="line">        17: dup</span><br><span class="line">        18: iconst_0</span><br><span class="line">        19: getstatic     #9                  // Field instance:Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">        22: aastore</span><br><span class="line">        23: putstatic     #1                  // Field $VALUES:[Lcom/xixi/design_pattern/EnumSingleton;</span><br><span class="line">        26: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 3: 13</span><br><span class="line">&#125;</span><br><span class="line">Signature: #34                          // Ljava/lang/Enum&lt;Lcom/xixi/design_pattern/EnumSingleton;&gt;;</span><br><span class="line">SourceFile: &quot;EnumSingleton.java&quot;</span><br></pre></td></tr></table></figure>

<p>其中，初始化是在静态代码块部分（<code>static &#123;&#125;</code>），重点Code如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new: 在堆中开辟空间，并返回引用压入栈顶</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>  <span class="comment">// class com/xixi/design_pattern/EnumSingleton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup: 复制栈顶元素</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldc: 将String instance压入栈顶</span></span><br><span class="line"><span class="number">4</span>: ldc           #<span class="number">7</span>  <span class="comment">// String instance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iconst_0: 将常量int压入栈顶</span></span><br><span class="line"><span class="number">6</span>: iconst_0</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokespecial：调用构造函数进行初始化 EnumSingleton(String, int)</span></span><br><span class="line"><span class="number">7</span>: invokespecial #<span class="number">8</span>  <span class="comment">// Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// putstatic: 将栈顶元素赋给instance</span></span><br><span class="line"><span class="number">10</span>: putstatic    #<span class="number">9</span>  <span class="comment">// Field instance:Lcom/xixi/design_pattern/EnumSingleton;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-1-反射攻击枚举型"><a href="#4-1-反射攻击枚举型" class="headerlink" title="4.1. 反射攻击枚举型"></a>4.1. 反射攻击枚举型</h2><p>尝试通过反射来获取枚举型的实例时，会报错：java.lang.IllegalArgumentException: Cannot reflectively create enum objects，从而避免反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xixi.design_pattern.singleton.attack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射攻击 枚举型：</span></span><br><span class="line"><span class="comment"> * 天然不支持反射创建对象的实例，会报错：java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionAttackEnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 从字节码分析得知，枚举型会自动生成一个私有构造函数，含2个参数 (String, int)</span></span><br><span class="line">        Constructor&lt;EnumSingleton&gt; declaredConstructors = EnumSingleton.class.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        declaredConstructors.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSingleton reflectInstance = declaredConstructors.newInstance(<span class="string">&quot;instance&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自己所需的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过反射引起枚举型报错的核心源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能对于枚举类型进行反射创建枚举类的实例，会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">    ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T inst = (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-序列化攻击枚举型"><a href="#4-2-序列化攻击枚举型" class="headerlink" title="4.2. 序列化攻击枚举型"></a>4.2. 序列化攻击枚举型</h2><p>基于“3.2. 序列化攻击静态内部类”对反序列化源码分析的基础上，来看看枚举型情况，在 <code>readObject0(type, false)</code> 方法中，在 case-when 的 TC_ENUM –&gt; <code>readEnum(boolean unshared)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="keyword">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_ENUM) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!desc.isEnum()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">&quot;non-enum class: &quot;</span> + desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enumHandle = handles.assign(unshared ? unsharedMarker : <span class="keyword">null</span>);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(enumHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到枚举的成员instance</span></span><br><span class="line">    String name = readString(<span class="keyword">false</span>);</span><br><span class="line">    Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 通过类名及类对象找到唯一的枚举类：调用前提是加载类且内存中存在数据</span></span><br><span class="line">            Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br><span class="line">            result = en;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">                <span class="string">&quot;enum constant &quot;</span> + name + <span class="string">&quot; does not exist in &quot;</span> +</span><br><span class="line">                cl).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">            handles.setObject(enumHandle, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(enumHandle);</span><br><span class="line">    passHandle = enumHandle;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取存储的Enum类对象</span></span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面分析可知，枚举型单例无需担心序列换和反序列化，可放心食用。</p>
<h1 id="7-在源码中的应用"><a href="#7-在源码中的应用" class="headerlink" title="7. 在源码中的应用"></a>7. 在源码中的应用</h1><h2 id="7-1-java-lang-Runtime（饿汉式）"><a href="#7-1-java-lang-Runtime（饿汉式）" class="headerlink" title="7.1. java.lang.Runtime（饿汉式）"></a>7.1. java.lang.Runtime（饿汉式）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-org-quartz-impl-SchedulerRepository（懒汉式-synchronized方法）"><a href="#7-2-org-quartz-impl-SchedulerRepository（懒汉式-synchronized方法）" class="headerlink" title="7.2. org.quartz.impl.SchedulerRepository（懒汉式-synchronized方法）"></a>7.2. org.quartz.impl.SchedulerRepository（懒汉式-synchronized方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scheduler scheduler = new StdSchedulerFactory().getScheduler(); --&gt; SchedulerRepository schedRep = SchedulerRepository.getInstance();</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SchedulerRepository inst;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SchedulerRepository</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SchedulerRepository <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="keyword">null</span>) &#123;</span><br><span class="line">            inst = <span class="keyword">new</span> SchedulerRepository();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-Spring源码-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry-（懒汉式-双重检查）"><a href="#7-3-Spring源码-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry-（懒汉式-双重检查）" class="headerlink" title="7.3. Spring源码-org.springframework.beans.factory.support.DefaultSingletonBeanRegistry （懒汉式-双重检查）"></a>7.3. Spring源码-org.springframework.beans.factory.support.DefaultSingletonBeanRegistry （懒汉式-双重检查）</h2><p>Spring 中的单例：只有一个共享的实例存在，所有对这个 bean 的请求都会返回唯一的实例。  </p>
<p>Spring 中加载单例的过程一般是从 <code>org.springframework.beans.factory.BeanFactory</code> 的 <code>getBean()</code> 开始，其默认实现为抽象类 <code>org.springframework.beans.factory.support.AbstractBeanFactory</code>。  </p>
<p>各种 <code>getBean</code> 最终会调用 AbstractBeanFactory 的 <code>doGetBean()</code>，如 <code>org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 对传入的beanName稍做处理，防止传入的beanName名有非法字符</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 直接从缓存中获取单例工厂中的objectFactory单例</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">// 若为单例，则进入getSingleton的重载方法</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getBean()</code>方法中 <code>Object sharedInstance = getSingleton(beanName);</code> 为核心单例模式（Double Check）的实现，<code>getSingleton()</code> 方法为 AbstractBeanFactory 的父类的父类 DefaultSingletonBeanRegistry 的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查锁实现的单例模式</span></span><br><span class="line"><span class="comment">// singletonObjects--&gt;earlySingletonObjects--&gt;singletonFactories--&gt;创建单例实例</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// singletonObjects: 检查缓存中是否存在实例，单例对象的缓存 beanName -&gt; singletonObject</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// singletonObject: 若为空，则锁定全局变量（singletonObjects）并进行处理</span></span><br><span class="line">    <span class="comment">// isSingletonCurrentlyInCreation: 这个单例Bean正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// earlySingletonObjects: 如果此bean正在加载，则不处理</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用预先设定的getObject方法</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 记录在缓存中，earlySingletonObjects 和 singletonFactories 互斥</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般第一次在 <code>doGetBean()</code> 中调用 <code>getSingleton()</code> 缓存中拿不到对应 bean 实例，会继续往下走，进入 <code>if (mbd.isSingleton()) &#123; &#125;</code> 块中，此时会调用 <code>getSingleton()</code> 的重载方法，在该方法中完成该 bean 的实例化后，会将该 bean 缓存到  singletonObjects 中，以便后续直接返回该单例 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 因为创建过程中需要操作 singletonObjects，所以需要加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 1. 再次尝试获取bean，判断bean是否已经加载。如果加载直接返回</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 判断，如果当前beanFactory正在被销毁则直接抛出异常，不允许创建单例bean</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                                                          <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                          <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 做一些bean创建前的准备工作： 记录beanName 正在加载的状态(添加到 singletonsCurrentlyInCreation 缓存中)，若bean已经正在加载，则抛出异常。为了解决循环引用的问题</span></span><br><span class="line">            beforeSingletonCreation(beanName); <span class="comment">// 将 beanName 添加到 singletonsCurrentlyInCreation</span></span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 通过回调方式获取bean实例</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5. 加载单例后的处理方法调用：删除bean正在创建的记录(从 singletonsCurrentlyInCreation  中移除 beanName)</span></span><br><span class="line">                afterSingletonCreation(beanName); <span class="comment">// 从 singletonsCurrentlyInCreation 中移除该 beanName</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 6. 加入到缓存中，并删除加载bean过程中所记录的各种辅助状态的 ==》 添加到 singletonObjects</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-Spring源码-org-springframework-core-ReactiveAdapterRegistry（懒汉式-volatile双重检查）"><a href="#7-4-Spring源码-org-springframework-core-ReactiveAdapterRegistry（懒汉式-volatile双重检查）" class="headerlink" title="7.4. Spring源码-org.springframework.core.ReactiveAdapterRegistry（懒汉式-volatile双重检查）"></a>7.4. Spring源码-org.springframework.core.ReactiveAdapterRegistry（懒汉式-volatile双重检查）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since Spring 5.x</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactiveAdapterRegistry</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReactiveAdapterRegistry sharedInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReactiveAdapterRegistry <span class="title">getSharedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReactiveAdapterRegistry registry = sharedInstance;</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ReactiveAdapterRegistry.class) &#123;</span><br><span class="line">                registry = sharedInstance;</span><br><span class="line">                <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registry = <span class="keyword">new</span> ReactiveAdapterRegistry();</span><br><span class="line">                    sharedInstance = registry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-5-Spring源码-org-springframework-aop-framework-ProxyFactoryBean（懒汉式-synchronized方法）"><a href="#7-5-Spring源码-org-springframework-aop-framework-ProxyFactoryBean（懒汉式-synchronized方法）" class="headerlink" title="7.5. Spring源码-org.springframework.aop.framework.ProxyFactoryBean（懒汉式-synchronized方法）"></a>7.5. Spring源码-org.springframework.aop.framework.ProxyFactoryBean（懒汉式-synchronized方法）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title">ProxyCreatorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object singletonInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">                <span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">                Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">                <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">            <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">            <span class="comment">// 创建Aop动态代理，然后获取实例</span></span><br><span class="line">            <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-Tomcat源码-org-apache-catalina-webresources-TomcatURLStreamHandlerFactory（懒汉式-双重检查）"><a href="#7-6-Tomcat源码-org-apache-catalina-webresources-TomcatURLStreamHandlerFactory（懒汉式-双重检查）" class="headerlink" title="7.6. Tomcat源码-org.apache.catalina.webresources.TomcatURLStreamHandlerFactory（懒汉式-双重检查）"></a>7.6. Tomcat源码-org.apache.catalina.webresources.TomcatURLStreamHandlerFactory（懒汉式-双重检查）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatURLStreamHandlerFactory</span> <span class="keyword">implements</span> <span class="title">URLStreamHandlerFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TomcatURLStreamHandlerFactory instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TomcatURLStreamHandlerFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getInstanceInternal(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TomcatURLStreamHandlerFactory <span class="title">getInstanceInternal</span><span class="params">(<span class="keyword">boolean</span> register)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class var1 = TomcatURLStreamHandlerFactory.class;</span><br><span class="line">            <span class="keyword">synchronized</span>(TomcatURLStreamHandlerFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> TomcatURLStreamHandlerFactory(register);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程-单例模式</a><br>[2] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Q5411T7FY">清华毕业大牛终于把23种设计模式讲的如此清晰脱俗，保姆级教程通俗易懂</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/17/design-pattern-overview/" rel="prev" title="设计模式概览">
      <i class="fa fa-chevron-left"></i> 设计模式概览
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/17/factory-method-pattern/" rel="next" title="工厂方法模式">
      工厂方法模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-%E7%AE%80%E4%BB%8B"><span class="nav-text">0. 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-text">1. 懒汉式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%88%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%89"><span class="nav-text">1.1. 懒汉式 - 线程不安全（不可用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%87%92%E6%B1%89%E5%BC%8F-synchronized-%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">1.2. 懒汉式 - synchronized 方法（不推荐使用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%87%92%E6%B1%89%E5%BC%8F-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E9%94%81%EF%BC%88%E4%B8%8D%E5%8F%AF%E7%94%A8%EF%BC%89"><span class="nav-text">1.3. 懒汉式 - 延迟加锁（不可用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%87%92%E6%B1%89%E5%BC%8F-%E6%97%A0-volatile-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">1.4. 懒汉式 - 无 volatile 双重检查（不推荐使用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E6%87%92%E6%B1%89%E5%BC%8F-volatile-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">1.5. 懒汉式 - volatile 双重检查（推荐使用）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-text">2. 饿汉式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">3. 静态内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">3.1. 反射攻击静态内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">3.2. 序列化攻击静态内部类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%9E%9A%E4%B8%BE%E5%9E%8B"><span class="nav-text">4. 枚举型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB%E6%9E%9A%E4%B8%BE%E5%9E%8B"><span class="nav-text">4.1. 反射攻击枚举型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E6%9E%9A%E4%B8%BE%E5%9E%8B"><span class="nav-text">4.2. 序列化攻击枚举型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">7. 在源码中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-java-lang-Runtime%EF%BC%88%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%89"><span class="nav-text">7.1. java.lang.Runtime（饿汉式）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-org-quartz-impl-SchedulerRepository%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F-synchronized%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-text">7.2. org.quartz.impl.SchedulerRepository（懒汉式-synchronized方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-Spring%E6%BA%90%E7%A0%81-org-springframework-beans-factory-support-DefaultSingletonBeanRegistry-%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%89"><span class="nav-text">7.3. Spring源码-org.springframework.beans.factory.support.DefaultSingletonBeanRegistry （懒汉式-双重检查）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Spring%E6%BA%90%E7%A0%81-org-springframework-core-ReactiveAdapterRegistry%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F-volatile%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%89"><span class="nav-text">7.4. Spring源码-org.springframework.core.ReactiveAdapterRegistry（懒汉式-volatile双重检查）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-Spring%E6%BA%90%E7%A0%81-org-springframework-aop-framework-ProxyFactoryBean%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F-synchronized%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-text">7.5. Spring源码-org.springframework.aop.framework.ProxyFactoryBean（懒汉式-synchronized方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-Tomcat%E6%BA%90%E7%A0%81-org-apache-catalina-webresources-TomcatURLStreamHandlerFactory%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%89"><span class="nav-text">7.6. Tomcat源码-org.apache.catalina.webresources.TomcatURLStreamHandlerFactory（懒汉式-双重检查）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Roy"
      src="/images/dinosaur.jpeg">
  <p class="site-author-name" itemprop="name">Roy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
