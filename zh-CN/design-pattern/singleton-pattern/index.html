<!DOCTYPE html>
<html lang="en,zh-CN,default" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="developer,blog" />
  <meta name="author" content="Xiangru" />
  <meta name="description" content="Happy Coding, Happy Life!" />
  
  
  <title>
    
      单例模式 
      
      
      |
    
     SissiLab
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/main.css">

  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    
<script src="/plugins/jquery.min.js" defer type="text&#x2F;javascript"></script>

  

  <!-- fancybox -->
  
    
<link rel="stylesheet" href="/plugins/jquery.fancybox.min.css">

    
<script src="/plugins/jquery.fancybox.min.js" defer type="text&#x2F;javascript"></script>

  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>

<!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&hl=zh-cn&subset=chinese-simplified&noto.script=Hans"> -->
  <!-- https://fonts.google.com/specimen/LXGW+WenKai+TC?query=LXGW -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@300;400;700&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <input type="hidden" id="xr-lang" value="zh-CN">
  <input type="hidden" id="xr-context-path" value="/">
  <div class="avatar">
    <a href="/zh-CN/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname">
      <a href="/zh-CN/" title="SissiLab - Xiangru">SissiLab - Xiangru</a>
    </div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/zh-CN/">
          <a href="/zh-CN/" title="Home">Home</a>
        </li>
      
        <li class="nav-item" data-path="/zh-CN/archives/">
          <a href="/zh-CN/archives/" title="Archives">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/zh-CN/categories/">
          <a href="/zh-CN/categories/" title="Categories">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/zh-CN/tags/">
          <a href="/zh-CN/tags/" title="Tags">Tags</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <!-- <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script> -->
    
<script src="/plugins/mathjax/tex-chtml.js" async type="text&#x2F;javascript"></script>

  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    
<script src="/plugins/clipboard.min.js" async type="text&#x2F;javascript"></script>

  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">单例模式</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2024-10-09
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">&nbsp;/
                  <a href="/zh-CN/categories/23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23 种设计模式">
                    23 种设计模式
                  </a>
                </span>
                
                <span class="span--category">&nbsp;/
                  <a href="/zh-CN/categories/23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="1. 创建型模式">
                    1. 创建型模式
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="标签"></i>
                
                <span class="span--tag mr-8">
                  <a href="/zh-CN/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">
                    #设计模式
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/zh-CN/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式">
                    #创建型模式
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="0-概述"><a class="markdownIt-Anchor" href="#0-概述"></a> 0. 概述</h1>
<p><strong>单例模式（Singleton Pattern）</strong> 是一种创建型设计模式，确保一个类有且只有 <strong>一个实例</strong>，并提供 <strong>一个全局访问点</strong> 来获取该单例实例。</p>
<p>维基百科：</p>
<blockquote>
<p>在软件工程中，单例模式是一种软件设计模式，它限制一个类只能有一个实例。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
</blockquote>
<p><strong>关键特点</strong>：</p>
<ul>
<li><strong>单一实例</strong>： 一个类只有一个实例。</li>
<li><strong>全局访问点</strong>： 提供一个全局访问点来获取该实例。</li>
</ul>
<p><strong>基本结构</strong>：</p>
<ul>
<li><strong>私有构造函数</strong>： 构造函数被设为私有，确保该类无法在类外部被实例化。</li>
<li><strong>私有静态字段</strong>： 一个私有静态字段 <code>instance</code> 用来保存该类的唯一实例，并且该实例应在类内部创建。</li>
<li><strong>公共静态方法</strong>： 一个公共静态方法 <code>getInstance()</code>，通常作为全局访问点，用来返回该类的单例实例。</li>
</ul>
<img class="kroki" src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXMtYXNjaWkiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyMzVweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjIwNnB4O2hlaWdodDoyMzVweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMDYgMjM1IiB3aWR0aD0iMjA2cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48IS0tY2xhc3MgU2luZ2xldG9uLS0+PGcgaWQ9ImVsZW1fU2luZ2xldG9uIj48cmVjdCBjb2RlTGluZT0iMyIgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSI5Ni44OTA2IiBpZD0iU2luZ2xldG9uIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxOTIiIHg9IjciIHk9IjEzMiIvPjxlbGxpcHNlIGN4PSI2Ni4yNSIgY3k9IjE0OCIgZmlsbD0iI0FERDFCMiIgcng9IjExIiByeT0iMTEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02OS4yMTg4LDE1My42NDA2IFE2OC42NDA2LDE1My45Mzc1IDY4LDE1NC4wNzgxIFE2Ny4zNTk0LDE1NC4yMzQ0IDY2LjY1NjMsMTU0LjIzNDQgUTY0LjE1NjMsMTU0LjIzNDQgNjIuODI4MSwxNTIuNTkzOCBRNjEuNTE1NiwxNTAuOTM3NSA2MS41MTU2LDE0Ny44MTI1IFE2MS41MTU2LDE0NC42ODc1IDYyLjgyODEsMTQzLjAzMTMgUTY0LjE1NjMsMTQxLjM3NSA2Ni42NTYzLDE0MS4zNzUgUTY3LjM1OTQsMTQxLjM3NSA2OCwxNDEuNTMxMyBRNjguNjU2MywxNDEuNjg3NSA2OS4yMTg4LDE0MS45ODQ0IEw2OS4yMTg4LDE0NC43MDMxIFE2OC41OTM4LDE0NC4xMjUgNjgsMTQzLjg1OTQgUTY3LjQwNjMsMTQzLjU3ODEgNjYuNzgxMywxNDMuNTc4MSBRNjUuNDM3NSwxNDMuNTc4MSA2NC43NSwxNDQuNjU2MyBRNjQuMDYyNSwxNDUuNzE4OCA2NC4wNjI1LDE0Ny44MTI1IFE2NC4wNjI1LDE0OS45MDYzIDY0Ljc1LDE1MC45ODQ0IFE2NS40Mzc1LDE1Mi4wNDY5IDY2Ljc4MTMsMTUyLjA0NjkgUTY3LjQwNjMsMTUyLjA0NjkgNjgsMTUxLjc4MTMgUTY4LjU5MzgsMTUxLjUgNjkuMjE4OCwxNTAuOTIxOSBMNjkuMjE4OCwxNTMuNjQwNiBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY1IiB4PSI4Ni43NSIgeT0iMTUyLjg0NjciPlNpbmdsZXRvbjwvdGV4dD48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSI4IiB4Mj0iMTk4IiB5MT0iMTY0IiB5Mj0iMTY0Ii8+PHJlY3QgZmlsbD0ibm9uZSIgaGVpZ2h0PSI2IiBzdHlsZT0ic3Ryb2tlOiNDODI5MzA7c3Ryb2tlLXdpZHRoOjEuMDsiIHdpZHRoPSI2IiB4PSIxNSIgeT0iMTc0LjY0ODQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0LWRlY29yYXRpb249InVuZGVybGluZSIgdGV4dExlbmd0aD0iMTMzIiB4PSIyNyIgeT0iMTgwLjk5NTEiPmluc3RhbmNlOiBTaW5nbGV0b248L3RleHQ+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB4MT0iOCIgeDI9IjE5OCIgeTE9IjE4OC4yOTY5IiB5Mj0iMTg4LjI5NjkiLz48cmVjdCBmaWxsPSIjRjI0RDVDIiBoZWlnaHQ9IjYiIHN0eWxlPSJzdHJva2U6I0M4MjkzMDtzdHJva2Utd2lkdGg6MS4wOyIgd2lkdGg9IjYiIHg9IjE1IiB5PSIxOTguOTQ1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc1IiB4PSIyNyIgeT0iMjA1LjI5MiI+U2luZ2xldG9uKCk8L3RleHQ+PGVsbGlwc2UgY3g9IjE4IiBjeT0iMjE4LjI0MjIiIGZpbGw9IiM4NEJFODQiIHJ4PSIzIiByeT0iMyIgc3R5bGU9InN0cm9rZTojMDM4MDQ4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dC1kZWNvcmF0aW9uPSJ1bmRlcmxpbmUiIHRleHRMZW5ndGg9IjE2NiIgeD0iMjciIHk9IjIyMS41ODg5Ij5nZXRJbnN0YW5jZSgpOiBTaW5nbGV0b248L3RleHQ+PC9nPjwhLS1jbGFzcyBTaW5nbGV0b25NYWluLS0+PGcgaWQ9ImVsZW1fU2luZ2xldG9uTWFpbiI+PHJlY3QgY29kZUxpbmU9IjkiIGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iNDgiIGlkPSJTaW5nbGV0b25NYWluIiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxMjkiIHg9IjM4LjUiIHk9IjciLz48ZWxsaXBzZSBjeD0iNTMuNSIgY3k9IjIzIiBmaWxsPSIjQUREMUIyIiByeD0iMTEiIHJ5PSIxMSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTU2LjQ2ODgsMjguNjQwNiBRNTUuODkwNiwyOC45Mzc1IDU1LjI1LDI5LjA3ODEgUTU0LjYwOTQsMjkuMjM0NCA1My45MDYzLDI5LjIzNDQgUTUxLjQwNjMsMjkuMjM0NCA1MC4wNzgxLDI3LjU5MzggUTQ4Ljc2NTYsMjUuOTM3NSA0OC43NjU2LDIyLjgxMjUgUTQ4Ljc2NTYsMTkuNjg3NSA1MC4wNzgxLDE4LjAzMTMgUTUxLjQwNjMsMTYuMzc1IDUzLjkwNjMsMTYuMzc1IFE1NC42MDk0LDE2LjM3NSA1NS4yNSwxNi41MzEzIFE1NS45MDYzLDE2LjY4NzUgNTYuNDY4OCwxNi45ODQ0IEw1Ni40Njg4LDE5LjcwMzEgUTU1Ljg0MzgsMTkuMTI1IDU1LjI1LDE4Ljg1OTQgUTU0LjY1NjMsMTguNTc4MSA1NC4wMzEzLDE4LjU3ODEgUTUyLjY4NzUsMTguNTc4MSA1MiwxOS42NTYzIFE1MS4zMTI1LDIwLjcxODggNTEuMzEyNSwyMi44MTI1IFE1MS4zMTI1LDI0LjkwNjMgNTIsMjUuOTg0NCBRNTIuNjg3NSwyNy4wNDY5IDU0LjAzMTMsMjcuMDQ2OSBRNTQuNjU2MywyNy4wNDY5IDU1LjI1LDI2Ljc4MTMgUTU1Ljg0MzgsMjYuNSA1Ni40Njg4LDI1LjkyMTkgTDU2LjQ2ODgsMjguNjQwNiBaICIgZmlsbD0iIzAwMDAwMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3IiB4PSI2Ny41IiB5PSIyNy44NDY3Ij5TaW5nbGV0b25NYWluPC90ZXh0PjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjM5LjUiIHgyPSIxNjYuNSIgeTE9IjM5IiB5Mj0iMzkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHgxPSIzOS41IiB4Mj0iMTY2LjUiIHkxPSI0NyIgeTI9IjQ3Ii8+PC9nPjwhLS1saW5rIFNpbmdsZXRvbk1haW4gdG8gU2luZ2xldG9uLS0+PGcgaWQ9ImxpbmtfU2luZ2xldG9uTWFpbl9TaW5nbGV0b24iPjxwYXRoIGNvZGVMaW5lPSIxMiIgZD0iTTEwMyw1NS4zNiBDMTAzLDc1LjgzIDEwMywxMDAuMiAxMDMsMTI1Ljc4ICIgZmlsbD0ibm9uZSIgaWQ9IlNpbmdsZXRvbk1haW4tdG8tU2luZ2xldG9uIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxMDMsMTMxLjc4LDEwNywxMjIuNzgsMTAzLDEyNi43OCw5OSwxMjIuNzgsMTAzLDEzMS43OCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjMiIHg9IjEwNCIgeT0iOTguMDY2OSI+dXNlPC90ZXh0PjwvZz48IS0tU1JDPVtLeXllQUlhZWpqQk5CeVg5cDJpZnBTdEhJeXhGcktfRUlJbWtyYXQ5SjRtbElpcGJ1VzlwNU84cHl6OXBLYWxveW5JZ2tOR0xnZWpCNGFpb2FzaUxDbEUwaEJwYUwyazQwZzBxZEFzWG9RTURLOW9VTWs4OUxRLVhZUW9aNWlDTXR5SENhNHIwMkxHWEZKcXg5QVRPQVBHTWZ0ODEwMDAwXS0tPjwvZz48L3N2Zz4='>
<p><strong>优点</strong>：</p>
<ul>
<li>只有一个单一实例。</li>
<li>提供一个全局可访问的单一访问点。</li>
<li>对于管理共享资源非常有用。</li>
<li>防止频繁创建和销毁实例，从而减少内存开销。</li>
<li>通过使用单一实例确保一致性。</li>
<li>基于延迟初始化（Lazy Initialization），实例可以在首次访问时创建。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不够灵活：它会使代码与特定实例紧密耦合，从而降低灵活性。</li>
<li>通常被标记为 <code>final</code>，或者以不能被继承的方式设计。</li>
<li>不适用于可变对象。如果相同类型的对象在不同使用场景中需要发生变化，容易导致数据错误。</li>
<li>如果功能设计不合理，可能违反<u>单一职责原则</u>。</li>
<li>使单元测试变得具有挑战性。</li>
</ul>
<p><strong>几种单例模式实现的比较</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>线程安全性</th>
<th>加载方式</th>
<th>推荐度</th>
<th>反射攻击</th>
<th>序列化攻击</th>
<th>完美版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#11-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">1.1. 懒汉式单例 - 线程不安全</a></td>
<td>×</td>
<td>延迟加载</td>
<td>❌</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="#12-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-synchronized">1.2. 懒汉式单例 - synchronized</a></td>
<td>√ (同步静态方法)</td>
<td>延迟加载</td>
<td>❌</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="#13-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%BB%B6%E8%BF%9F%E9%94%81">1.3. 懒汉式单例 - 延迟锁</a></td>
<td>×</td>
<td>延迟加载</td>
<td>❌</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="#14-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%97%A0-volatile">1.4. 懒汉式单例 - 双重检查锁定（无 volatile）</a></td>
<td>×</td>
<td>延迟加载</td>
<td>❌</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><a href="#15-%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9Adcl">1.5. 懒汉单例 - 双重检查锁定（DCL）</a></td>
<td>√ (volatile 实例 + DCL)</td>
<td>延迟加载 (DCL)</td>
<td>👍</td>
<td>× (<a href="#151-%E5%AF%B9%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB">1.5.1. 对“懒汉单例 - 双重检查锁定”的反射攻击</a>)</td>
<td>√ (<a href="#152-%E5%AF%B9%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB">1.5.2. 对“懒汉单例 - 双重检查锁定”的序列化攻击</a>)</td>
<td><a href="#153-%E5%AE%8C%E7%BE%8E%E7%89%88%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A">1.5.3. 完美版的“懒汉单例 - 双重检查锁定”</a></td>
</tr>
<tr>
<td><a href="#21-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F">2.1. 饿汉式单例 - 静态常量</a></td>
<td>√ (类加载机制)</td>
<td>饿汉式（类加载时）</td>
<td>👍</td>
<td>√ (<a href="#211-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB">2.1.1. 对“饿汉式单例 - 静态常量”的反射攻击</a>)</td>
<td>√ (<a href="#212-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB">2.1.2. 对“饿汉式单例 - 静态常量”的序列化攻击</a>)</td>
<td><a href="#213-%E5%AE%8C%E7%BE%8E%E7%89%88%E7%9A%84%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F">2.1.3. 完美版的“饿汉式单例 - 静态常量”</a></td>
</tr>
<tr>
<td><a href="#22-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97">2.2. 饿汉式单例 - 静态块</a></td>
<td>√ (类加载机制)</td>
<td>饿汉式（类加载时）</td>
<td>👍</td>
<td>√ (<a href="#221-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB">2.2.1. 对“饿汉式单例 - 静态块”的反射攻击</a>)</td>
<td>√ (<a href="#222-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB">2.2.2. 对“饿汉式单例 - 静态块”的序列化攻击</a>)</td>
<td><a href="#223-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97">2.2.3. 完美版本的“饿汉式单例 - 静态块”</a></td>
</tr>
<tr>
<td><a href="#3-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B">3. 静态内部类单例</a></td>
<td>√ (类加载机制)</td>
<td>延迟加载（静态内部类）</td>
<td>👍</td>
<td>√ (<a href="#31-%E5%AF%B9%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB">3.1. 对“静态内部类单例”的反射攻击</a>)</td>
<td>√ (<a href="#32-%E5%AF%B9%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB">3.2. 对“静态内部类单例”的序列化攻击</a>)</td>
<td><a href="#33-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B">3.3. 完美版本的“静态内部类单例”</a></td>
</tr>
<tr>
<td><a href="#4-%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B">4. 枚举型单例</a></td>
<td>√ (天生安全，类加载机制)</td>
<td>饿汉式（枚举类加载时）</td>
<td>👍</td>
<td>√ (<a href="#41-%E5%AF%B9%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB">4.1. 对“枚举型单例”的反射攻击</a>)</td>
<td>√ (<a href="#42-%E5%AF%B9%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB">4.2. 对“枚举型单例”的序列化攻击</a>)</td>
<td><a href="#43-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B">4.3. 完美版本的“枚举型单例”</a></td>
</tr>
</tbody>
</table>
<h1 id="1-懒汉式单例"><a class="markdownIt-Anchor" href="#1-懒汉式单例"></a> 1. 懒汉式单例</h1>
<p>懒加载意味着实例只会在首次访问或首次调用静态方法时创建。</p>
<h2 id="11-懒汉式单例-线程不安全"><a class="markdownIt-Anchor" href="#11-懒汉式单例-线程不安全"></a> 1.1. 懒汉式单例 - 线程不安全</h2>
<p>它在单线程环境下工作正常，但在多线程环境中可能会破坏单例模式，导致创建多个不同的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonThreadUnsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonThreadUnsafe instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonThreadUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonThreadUnsafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                // 模拟多线程环境下无法保证单例模式的情况，</span></span><br><span class="line"><span class="comment">                // 提高重现问题的概率。</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(200);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingletonThreadUnsafe</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试代码：</strong></p>
<ul>
<li>单线程环境：可以获取相同的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLazySingletonThreadUnsafeSingleThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LazySingletonThreadUnsafe</span> <span class="variable">instance1</span> <span class="operator">=</span> LazySingletonThreadUnsafe.getInstance();</span><br><span class="line">    <span class="type">LazySingletonThreadUnsafe</span> <span class="variable">instance2</span> <span class="operator">=</span> LazySingletonThreadUnsafe.getInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;instance1: &quot;</span> + instance1);</span><br><span class="line">    System.out.println(<span class="string">&quot;instance2: &quot;</span> + instance2);</span><br><span class="line">    <span class="comment">// `instance1` 和 `instance2` 是相同的实例。</span></span><br><span class="line">    Assertions.assertSame(instance1, instance2); <span class="comment">// √</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多线程环境：可能会获取到不同的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLazySingletonThreadUnsafeMultiThread</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    Callable&lt;LazySingletonThreadUnsafe&gt; callableTask = () -&gt; LazySingletonThreadUnsafe.getInstance();</span><br><span class="line">    Future&lt;LazySingletonThreadUnsafe&gt;[] futures = <span class="keyword">new</span> <span class="title class_">Future</span>[THREAD_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">        futures[i] = executorService.submit(callableTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LazySingletonThreadUnsafe</span> <span class="variable">firstInstance</span> <span class="operator">=</span> futures[<span class="number">0</span>].get();</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;LazySingletonThreadUnsafe&gt; future : futures) &#123;</span><br><span class="line">        <span class="type">LazySingletonThreadUnsafe</span> <span class="variable">instance</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        <span class="comment">// 在多线程环境中可能会破坏单例模式，导致获取到不同的实例。</span></span><br><span class="line">        <span class="comment">// 如果问题无法重现，请尝试多次运行测试方法或取消注释 LazySingletonThreadUnsafe.getInstance() 中的代码。</span></span><br><span class="line">        Assertions.assertSame(firstInstance, instance); <span class="comment">// ×</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-懒汉式单例-synchronized"><a class="markdownIt-Anchor" href="#12-懒汉式单例-synchronized"></a> 1.2. 懒汉式单例 - synchronized</h2>
<p><a href="#11-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">1.1. 懒汉式单例 - 线程不安全</a> 不支持多线程场景。我们可以简单粗暴地在 <code>getInstance()</code> 方法上添加 <code>synchronized</code> 锁。虽然这种方法可以解决线程安全问题，但效率低下，因为它通过锁定静态方法来锁定类对象（类级别锁，而不是对象级别锁）。这意味着每次多个线程尝试通过 <code>getInstance()</code> 方法访问单例实例时，都会被锁定，只有一个线程能够访问，这大大影响了性能。实际上，这种方法只需在类实例化时执行一次，之后的所有请求都可以直接返回已经实例化的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonSynchronized</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonSynchronized instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonSynchronized</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步静态方法：类级别锁确保同一时间只有一个线程可以执行静态同步方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingletonSynchronized <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                // 模拟多线程环境下，多个线程并不总是获取到相同的单例实例，</span></span><br><span class="line"><span class="comment">                // 提高重现问题的概率。</span></span><br><span class="line"><span class="comment">                TimeUnit.MILLISECONDS.sleep(200);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingletonSynchronized</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-懒汉式单例-延迟锁"><a class="markdownIt-Anchor" href="#13-懒汉式单例-延迟锁"></a> 1.3. 懒汉式单例 - 延迟锁</h2>
<p>基于 <a href="#12-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-synchronized">1.2. 懒汉式单例 - synchronized</a>，我们可以考虑仅在第一次返回实例时锁定实例化过程。实例在临界区内被实例化，以确保多线程环境中的线程安全。之后的所有操作将直接返回该实例，而不进入临界区，以提高多线程性能。</p>
<p>但是，在多线程环境中仍然会存在线程安全问题。例如，在以下场景中，线程 T1 和 T2 可能会创建两个不同的实例。</p>
<ol>
<li>T1：刚进入临界区，尚未实例化：<code>instance=null</code>，T1 持有类级别锁</li>
<li>T2：进入 if 代码块，因为 T1 中的 <code>instance</code> 字段尚未实例化完成（<code>instance</code> 仍然为 null）：<code>instance=null</code>，T1 持有类级别锁，T2 在进入临界区前被阻塞</li>
<li>T1：完成实例化并退出临界区：<code>instance=LazySingletonDelayLock@4a87761d</code>（<code>instance!=null</code>），T1 释放锁，T2 有机会获得锁</li>
<li>T2：进入临界区并再次执行实例化：<code>instance=LazySingletonDelayLock@2db7a79b</code>（现在它返回了两个不同的实例，破坏了单例模式！）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDelayLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonDelayLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDelayLock</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 `instance` 为空时的 if 代码块中延迟锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDelayLock <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">// T2：此时仍可能进入 if 代码块，因为 T1 中的 `instance` 字段尚未完成实例化（`instance` 仍然为 null）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDelayLock.class) &#123; <span class="comment">// 类级别锁</span></span><br><span class="line">                <span class="comment">// T1：刚进入临界区，尚未实例化</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDelayLock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-懒汉式单例-双重检查锁定无-volatile"><a class="markdownIt-Anchor" href="#14-懒汉式单例-双重检查锁定无-volatile"></a> 1.4. 懒汉式单例 - 双重检查锁定（无 volatile）</h2>
<p>为了解决 <a href="#13-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%BB%B6%E8%BF%9F%E9%94%81">1.3. 懒汉式单例 - 延迟锁</a> 中提到的问题，我们进一步在同步块中添加检查，确认 <code>instance</code> 是否为空。如果为空，则进行实例化。这可以防止多线程场景下导致的多次实例化问题。</p>
<p>然而，由于 <code>instance</code> 字段没有标记为 <code>volatile</code>，仍然可能由于<u>指令重排序</u>导致错误。</p>
<p>在创建新对象（如 <code>instance = new LazySingletonNoVolatileDoubleCheck()</code>）时，内部实际上涉及三个主要步骤：<code>1. 内存分配</code> → <code>2. 初始化</code> → <code>3. 引用赋值</code>。</p>
<p>为了提高性能，JVM 允许对指令进行重排序，这三个步骤可能会被重新排列，如 <code>1. 内存分配</code> → <code>3. 引用赋值</code> → <code>2. 初始化</code>，这可能会导致线程安全问题：</p>
<ol>
<li>T1：进入临界区并准备 new</li>
<li>T1：内存分配</li>
<li>T1：引用赋值（因为此时尚未完成初始化，尽管 <code>instance</code> 现在指向新分配的堆空间，但对象只是部分初始化。）</li>
<li>T2：在第一次 <code>if</code> 检查时，发现 <code>instance</code> 不为空（T1 尚未完成完整初始化），直接返回了部分初始化的对象，导致程序错误。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonNoVolatileDoubleCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonNoVolatileDoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonNoVolatileDoubleCheck</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加双重检查锁定，但未标记 `volatile` 的 `instance`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonNoVolatileDoubleCheck <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123; <span class="comment">// T2：直接返回 `instance`，但此时尚未完全初始化，导致返回了部分构造或未初始化的实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonNoVolatileDoubleCheck.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonNoVolatileDoubleCheck</span>();</span><br><span class="line">                    <span class="comment">// 字节码：1. 内存分配 -&gt; 2. 初始化 -&gt; 3. 引用赋值</span></span><br><span class="line">                    <span class="comment">// 可能重排序如下：</span></span><br><span class="line">                    <span class="comment">// 1. 内存分配</span></span><br><span class="line">                    <span class="comment">// 3. 引用赋值 // T1：`instance` 被赋予引用，但尚未完全初始化</span></span><br><span class="line">                    <span class="comment">// 2. 初始化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经发现，创建一个新对象的过程中包含了多个步骤。接下来，让我们从 Java 字节码的角度深入理解对象的创建过程。首先，我们编写如下简单的测试代码来创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NewTest</span> <span class="variable">newTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewTest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>javac -g NewTest.java</code> 编译 <code>NewTest.java</code> 以获取 <code>NewTest.class</code>。然后，我们可以执行 <code>javap -v -p NewTest.class</code> 来获取类文件中字段、构造函数和方法的字节码信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Classfile /DesignPattern-Lab/src/main/java/com/sissilab/dp/ox1_creational/ox11_singleton/NewTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">25</span>/<span class="number">07</span>/<span class="number">2024</span>; size <span class="number">487</span> bytes</span><br><span class="line">  MD5 checksum e132b23dc7ec6394be9137ad5aa7c33a</span><br><span class="line">  Compiled from <span class="string">&quot;NewTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.sissilab.dp.ox1_creational.ox11_singleton.NewTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span> <span class="comment">// Java 主版本号 52 表示用 JDK 1.8（Java 8）编译的类文件。</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER <span class="comment">// 类访问修饰符：该类是 public（公共的）。</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">19</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">20</span>            <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/NewTest</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">19</span>         <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/NewTest.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Utf8               Code</span><br><span class="line">   #<span class="number">8</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">9</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               Lcom/sissilab/dp/ox1_creational/ox11_singleton/NewTest;</span><br><span class="line">  #<span class="number">12</span> = Utf8               main</span><br><span class="line">  #<span class="number">13</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">14</span> = Utf8               args</span><br><span class="line">  #<span class="number">15</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">16</span> = Utf8               newTest</span><br><span class="line">  #<span class="number">17</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">18</span> = Utf8               NewTest.java</span><br><span class="line">  #<span class="number">19</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               com/sissilab/dp/ox1_creational/ox11_singleton/NewTest</span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.sissilab.dp.ox1_creational.ox11_singleton.NewTest(); <span class="comment">// 自动生成的默认无参构造函数</span></span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/sissilab/dp/ox1_creational/ox11_singleton/NewTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>; <span class="comment">// main 方法</span></span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// new：为由 #2 引用的类的对象分配内存 -&gt; 将引用添加到操作数栈的顶部。</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/NewTest</span></span><br><span class="line">         <span class="comment">// dup：复制栈顶值 -&gt; 将复制的引用添加到操作数栈的顶部（因为随后的 `invokespecial` 将消耗一个引用）。</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="comment">// invokespecial：调用构造函数以初始化新分配的空间并消耗一个引用。</span></span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="comment">// astore_1：弹出栈顶值 -&gt; 将引用分配给 LocalVariableTable 中位置 1 的元素（`newTest`）。</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable: <span class="comment">// 将字节码指令映射到源文件中的行。</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>       <span class="number">1</span>     <span class="number">1</span> newTest   Lcom/sissilab/dp/ox1_creational/ox11_singleton/NewTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;NewTest.java&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然只有几行简单的源代码，但反编译后的内容却很庞大。主要集中在下面的代码部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/NewTest</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: astore_1</span><br></pre></td></tr></table></figure>
<p>下面是该过程的说明：</p>
<div class="excalidraw-svg"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1081.6370313640625 772.25" filter="invert(93%) hue-rotate(180deg)" class="excalidraw-svg"><!-- svg-source:excalidraw --><defs><style class="style-fonts"> @font-face { font-family: Virgil; src: url(data:font/woff2;base64,d09GMgABAAAAABiAAAsAAAAAJtwAABgwAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAgRwRCArDWLIAC1oAATYCJAOBMAQgBYMcByAb6RxRVM8qZF8c8ObQKYfzYhl1y0eMQV7LSUc0Z7N3uUsupuAxxBPEvyQhCSFYMGkJEtxq+o7U5SsKfVEqKnzfpOb8pdNPuuuk1vChPSAob3rArtlt97UkcKzAWjLF+SA7QCTo/4ACgf+b0+/lrbS9unKcwoPgA6ZVOjlzMsCfNptm27eVHduhgu1QYSDw27QD1DfAsvXBlOXQVLP2iL9rg5pCeIzD/fKh/Wb9h1cRqZROLMdHH8zsEEuTJN6uzWIVtSQa99fqQiuUuFJmaW2tg0+xU6RcNovrixdnAhpmQf1AAGAfYQUAkAKVbjjAJxAKryMWIEiMYYA7IJ3GroUZZjPoQA59eNf7j4BoR6AuAODlmi3oHPY2Fk89U0QmxCqHvJYGC5gH8KfAJTxMBX4QDOEQBbFggVTIgTxogW7oGx8HqAr7QhBoSLauFNp+q/Ex99xy3TVXXHLUIT+Mfz8+Mj48vhcQYAiNA0zKA0mBEKFhpRTZbwE9DEAJAxSaMZ8seCVgiYQb5zSnP3CjKCjcU+gp9Z3EKyvIFIsnTcjM+EDrFCcOkIXma2VFBUYnN5lvuspmdpX7i4PMFbZYW/Id+ZvHyLBXDVdO3xHQXjM0MrWKekNDt4Wf6azUExbrNYJQP43wKeQllFy0bZuJyPbz8b3b9ZweMB88gkpFIObiTB4JdqlxDF03qnGggBhMeFKzuXIBgyHFQEoo++9hZEXa4KUgCCQ0HMWbRIp6kOHIR5fXyo6yGem8aKMY50QtE6zUtjt5SKENSuJFwe5+CWNFHLXw/v2/st2cUQFN/8QbL/vqoU4/yqVf7CYnogRb7M/nV4West7eXrxRpkoXHfUIh1vTUKlx+sb/8VNhcN+nCadRyAdmcAmjMXo4HGKeG5YTMbp6miDP5uGlPrW59O3axLaZo9ilwMK9i8LBkfLmp9haTLTPMrHvzmp7ndyY/EjNJTyFjlWY/v+8RhxS0xf1bpcBJ/KGgj+QqFJYsNSgcYzI0OWV6UXQHIyRLsetnShngmHQNQPY7VsuSUc6YHesyc3d6dNTgeJ54x7zqkRhaPeCllNI8ZQehAXMDa9UQLcL+O+cpeZK6uBk4e3VtNRs7r7L1Lwyf9X1q2AN0Yt5KfBQOupTRPx1/4Nh8r1X5chxMFoTonWMasgJTal59M7kaHxR9ifNkspzIdj9GbBop54UvIwnT4Ez8PfRyXiWO/q2vKrJvtytWjeS8t+j8wMzUCa6+IvA6fKxwEOYMKkJ0e06HU+z2YZJ0oWxMgezap2iDGiHoOdxVbAGRvgBO75TN1xd0dN8r7Mvnos2xEHPKGpw56h0QgFaCwhh34IQI5tsp2gZAmX6kF03g0e2hDMFlUfmCnYHq15tJqL5hY3K4lVhkMJlQFdKikvI/YV4mvV7B6kL2CCqC9zHV+9XaKD0YOGazQ3Ti/PuRHC9NhBtWRN6zXB1y9Bb+awYLgKqxlNlM9jPnk4yIaJWXd3KT48rE9WMkiRYbiigFa8BKCV4Bxol7xbK30czTL+eXzxZW6LTuupgIlYZpIr0vAJ0m0Dnpwwu1jGqhXbIKbRt4gQZzyTlaCBWi1Rcvw+xru1aUYKVzvpHosPxVZgwGXSmnZ+E/PRT7LfvyXPJOGciykEAVkFRdsLtmJd8OdNR58600BQ3/qbXqhZjNf4DYe3cRYrT9a02mXQEhGEedJn0dw3yJEcJ6VLGDKln4C2kAceYUDzrYAGllGhPsEadvL2SJdu2PV6SYi6fidrqViayEQ9NJLgLBTrKVA2CgAU7tnguSua6icX+JnZLWvzqtyHrQ8im+mJtMBE+8Z+JO8GxMTWfU2/dB1ilnLEJqOn/KwSUF12SOLPS5EiLB/neY3ofzTvnapPraH2/KhL9xY8idhksPF/WbPZ4eaA9Tj2bh6eTEvCckZETYWuYvDNgkL/cHeZ0G63K2J/XP+pXlkSsD8sFfEsGsx1lFmwDe1dYLfB4Gs+EH3cLhR5pJT0k6dnVkE8fkhtK/HUupeYZSllOvrm5q89n273i4EAAJnDwFfIY7G63oBoeXz6/vvAneYBdyJ9U0+o4Kbu1z+kfM0pGcDEu2NljIGrT6b9jo05Je03Eedrm5LkcV4gqBcp0iDT55+FGzENAao5w39/0W4gKivvR+NdjlFRqO5Vjt7Cg7llqXgwpw16idI32O6di9aEvNne27uG3QZ4rtNJFXQZOYfjyJTttiX98pGtedd9TssJY5aJBVkZCJ0akRdTeEiMG2WkcN5Y5eS5BV6K1IoMT5CSX7s4UbE7j8+cN6maQmgRn1GScJ6QTp5QMgM9THSuOnplP9VXvbRDZZ1rEOu0dhc2DjWQu0Vc3GdxWnpTAD06A0sZWvMdA/5ZKLvqEH764CKEyCxTtcQYzF5pGfav7vv25W8D4ElJjsYMt7VdrItGrlRUnaZc7nGybl2kVE8cXfTVjUNyOD5bpBgJSk5ucqaLVUwZZWeHjm3SdPPDs+EdMW69zkkSjdHyeUqrprXDVcMkrbOyR4dsrDDi9Sr0eb87ENMF08414GstuPJDb00vMMyVJkgd8fbZ8LBxbo+ZJ+uPODeVLyl3U1FPKHGdya3I2q6dl7s2o1bYkm51WzSYPiUNi86dOlpdprcMgSxs3xJMHkAPJIHh1ySlJ+YwPSv0LlS3p+cX/H4oZFBX/k0gRgFa8ZpPTDt4Ph5/61cpTPLg7P7I2s73jTnOgxUp+Wny5EKxmVxMDTC32W86qEVHswgKNn/DMBLsSbIRsuB5DAaS5xb7hdtp7fyv3KzPI/WIGtND4rFp6esAhFRLlEvlLyGAgpFZ7ySTcsFNl6E/VJCFgQA3yJlZFbuEQTdnlqpDpVGwyiG+X/QI4DL6nJ7+NzTJtnP4DdU6qvhNhFTYZhD58ioxE16ss/fX0mJyh5D066kGe3PCUIgVDU7dJB+tipTqp1u16gfaW0nYymZ/hRg3WSoppSb65uXnfy+VGeRLsBd6JIjTjIIDGlhk2VlLkudI8cOdJ53RZ6uJ4Q6NRuM/gotRP88GVct/H7lXRojYIX9r4Aj5XMN/KPAgAXb4eX17/I5731fCrI285K/+tD0VYzM0Q2fGR2+LHU2u/VN8jRTEHm2X7na+/ns70wQ4VNOy5hlpuptTxAQchgODcK86KnXo6D+Puz49wSGdH+NNWOkqQ/9ZMnmPrM7FDHs6oY524uLwDXxdFuHFoS93Lf+z/EG22/DVDDJcPy0DIiJFtL7pEQWNMgk+KUwZ5GQy26ltC1ysfkfdj0kuVpA2vx3uiHsX6qJynHlHHCmA3NMGXzdpoHBx+vjlXFaPXuiwKjxhdFHtPrpoe9EudWWKiRVtimoewvsfnSJONvtExufv7q786OFYg1Lfo7MzjucMEy7r1mWi1bbnaf9fjcYQzg2u1mtjUV0WI4IRWOpNuZMT186+ncdyfNtsMLuUlDFwWHh8do/0Xw78xbfc4FTABg++wWT1RHeZ0OtESQrJYLgF94S8Grw/hf13jUEN8JO+SuQaO+TDODxb227nlbV3ZPl7cZIcr6RtKz9O7gGsurVtQgHNI38T1jLHWsMwkrSRvN2UFwkqLIW8wnDwmC7MZyomM9YKj87qE7sFu1H8cPBIz0dasE+ZOXyxgdpFta78KJEazYbUH4+qJ2Z8Fw6zYz35OuR9MdYlDhWG5+c+yMkkMxSLMrcF8YMZB3ohS6LK5aT+LvoM6n66IHZSVyBPRm0I/bBhHQJ0K/8ZgeRcyXxBXF4nESMgP1Ss6ciOWLVGXi2MsBZ3Kbr/xnDFn1iTKYH927rvz7nKgY5WCoFz/9u44VfvkbVnrTvMF8Br4gtv7JRz6etry6wxVYpoya7Yyz20Bx2LWz8SveF6RDhyg6E9xHohJmeWJTPyC6P/9on3t+vJDhWNVMwaldp/+48b7guXbwOgkTUG9Fb95D2WwSksPSWasboTp1pg1JpZ+9m3kwyDKfXP0+h7lmCo3cMFXGypp3rbUO6apE+M/QYVOpUFThK/oRe89dVHf9vgZ1z2BkZJDaergma+WXdo4M34hVKV5s8Q+zk55/7PFT6TZvRHIhbmvjImxebQGLmcSXp3cS2OL/kZGNOqBQfHAlTvd9FpyxAPvi5/MNHjtpa/scWrNa1w2q0GEpMgLhcmz9Lrw77xCypR/Z+XJY+5T0MWpm6rK9jNcrOq7MmPREQM/IcejZle8nF6x8IJgSrMtPpssvXhy+a4RdFHisyH+/zfGj2lj+V+KFHyEs49KnVXn4RlOkiHmBeWzipVPMsVWXZpi9/GMH6PjqCXX96U6by/mVJaZypdbD/i8HbZJdZKXbaXUWLpYXO5s/WzCJ5cuBtv/nP3oC0HpB7RqMMfnrd9Gm5dENkyCvghL4e+l8yJYNGO2cWUDfe3jsYWOl6YxmP7f0Qfp4tOOtVZnBhc7nZhvMm0f3PPRg6yiZ8SzdRELq0Xd/iEv6BGIvwyJFWU3BGaZgCPMHpFIgtZhSr8Fc3Zv4a1h8x8L0dVQbvQnrhJ5AGjatUpTCZ9B4IE0yOzj8QrXjs4Z/SYk0CHyX/RY4V3D5Mlv17ksvzzyWJiO6XEMaeS4H67RgMYujnR/SP4U3NohiPPSWp8s6kziNJ8I+AxLQcfwKaPY0bOeZoasQ2Un7TQH5Q8ZOa4eW3huC1gbWcgQ+SGpk2r2+NN+mhHH5/xVQQ9Apl6MO/fArKXOE6HyBwPRpz5tZooZpaPtCTUqySyiJsDJ1sNXlkwoCGEVoixsFBdt5D93bmhjcKkkhQcyIs7XQoZBAq+C3abiFllIca1NHVXpLN1+DOFYfrMryuBSJle/DFHHPjk5i7J54XZYitdRWdgefWbUb/8ma9RFET0SqzZgUiCDLEV/LgliiTZwrJv/KXjqN9FNRBU23QxTHZ7PnLE26+OsqSBwrZpG4fXBGDWPC8wOfvCY9xIt2vbUW4es1F/9S7JN2txGn8nxvGur9rTaNGgy/vX9j2ckQdvga8OBReXzdCyifx5WgmyiGs2uKeH709yY5IEVKZ7t/REJ6XMnPdPHNzoaUTuWrtyyrRhSUrklGlsOZKBprR7js1QSXrz763K/JdmyErqOcMzF17bwiRamBY1ZaQGkWeHJQMv4Leta2JvYIkL3QEf8Rc+H8wwmtXw97jRd+R3/iCExzIHSCRHtBMiiZr60j3xvPoKU25SOOo+8sydqespGPdKk1mTOL9j+6Y8ff4vlBkZ456hzvyv5egduw3zD3qVVzt+f3PNxaO/APvX8Hte/M6M0IDM4n85FGsLMIluIx3t5tu94ayRkcZV8A5Yrj+U4kgSB7CoiASewhhnbGTZiBv8NEclgfwR5hqdF0KPs1s4l1itC9we26tplGXX24eJNsOTzzvXJlca1D/RO3p/WXc/Ilfgjf9M3gZXKAQsvgy6oXR59+vZkrWNi+PrwzspX/fxtmG8cWu3EnuVdHmfQzsmr8pe4qAXX0BSHBe+hh1tpYUMFwy00kEV+w3SV/MeR1N0WLGG6PSR48934HzEMchx/pqNlkgLLcs9gmzK65cMlqeF2VJnkZw2mSpClQUdF7/N+aOLCa2OWYLh35AuxKHF4iSMNeAebPp8lLfX5Q3dMUdWUcGwU3/drTPimP1sfdV5uSMXLAjY+j1/bKOxxdhwn4v98WnG+QWQt83z3GohtdCpjdl86W78BY45kaRQjjjCwtexXyF7URZlWSxHei6QM+yrOtFn0+K8fZrmmBMl4ZBPpxa5Xe6apdYClYCH5bq46q8ffEXRizzL//aTtrfhYbGpYUvKhYxztiZu7XpGZUOWWVJzrWoVfKDYH0vLyEyNl4b8qSa0CUUxdZ5EeH5LiwYNBQ/SybyivaMP6z4/+Js/HbZpkL5+Jf/k090kkP8+hzWKoUALbX+f67ItMJ5cbVSgS0qm+LYWS6SpPfn/sMIlKZSSrmCXaNy4q8hO9aE7VFUyqGPFOUlCEatvpjY7/c5yMsbrcyvw09R9Hbdy53NqjJxaL8i8tmRAATySu9ZK13jLnLgbBiHabzqLfTlMMvJw/y69PIkyE1NtlMuF3xsEXShySBWTKhBhuZzIrLlSTMj/WwozLzjuUHpUEJIP93eiXpgcfJBvj4pK3VX0ruKWWG8Slnh+vxPkPNMP6OWoznUlzj64xBXzKX0Dmdt8O/EMoMkcVNa7QOUPsv9/51Ycn13DYV1nSQeGKcDVO44SEabAUIV6MOVOtTjGs2W0w/utdZlBMYgMlIrs6e6qkUoVF7Fmwxq3A30ssyGMxvC9bZGYmLxE4gZN+RraBTdk7QwvyYwS1zG4p5vcpn9po+dOVbqMX0F3c//Q+ck7S2HwpiKEMQViIX51hI3BA5WWTsrqN7xfsmCo1r6D7cxKGM1OCFIHuAz9lfiPlzi3goLoci+f+j32ec8M4JVzLDu7L+8vDQq46STP+Lgr1O+zwps35qjAdVn+2pwJhDIwq35Ax1XRsW1jQtyxmtbvBX0R8pvlSjenr6cWqXkvb2pe1Swm95rfNbAFZjZPmlwc7bBPLIJH5UwCfDGg3uQ8UXJhm4hpuYnXBkLKHxTpJB4oV1Ct18+Qw8SQmB00U1yIrJ8a/ZnQNp++YWHYMST7IhBZ5aeCj3kcFfl8/E0eVOlTxab3Xdy+0jjIKUf5P7iu82d0Hc8abdnwUNAWroLTZxh7BqgyhSYXCUv8dwm4n5LPqMC0Y7V6Gj2kb7erV2JNYKXsARDx9VESWKDi9dZ3xe89k1iJ3Ao/BCRo/8aH8UF0AxUSdkF+THnnTfHWUz9hQ11+/zyMpV5iJH0Auf8lrSKazsKpaqC/x3mVJKmOA25yGOv/av7rfbF6aYF2QcCzMvDOhcarbM0eLhuFf+2NyekDjw331Ab550uRoM4t7cJlneE5woDR61rKTs5W8b3cRRa7eoGU+PCEycehDnR4ayzv2tP+aJihvZoWvolHYPAW9LrZycFnk3paWm3k/CHySmFsYUOWCskoo49DEiJ7sFLd41xMuhsRTNxZsGnJNJigFqFj19xZpY8zHcsLDcFmI7Sm3I9z5xnmGRnfly9yED90nBOTVS3+wrvuYw/172vXVoDeJrnhFh/7tvnGvjiUNHArrClqdZnB4pMSYyy+6ko36RNGrEnU2gSnwR9phY5dFkjWXyHw40vnm2uW5L+4NZ2I0Jju5pC1VdOmhoFUxbRps+Q5luqfkJeppcsp9b/mt+4kxogK2pkpYjVbWSDcGe6H8KvQM097cq7+waTvMLHth5u/l97PMbG9p4m4X7UPqouaJbVg/x9RdOyWJ1ineNXrhTqbOPjkqzdYqn8a6UOx18UsvRE9kAKxz1kWf2UnHafYNXMUrNRZYSaU2BTyJYZFEoSZqcZ/F+w7++7WEi6haKGXmcsjg5yKlduY1rPXDYDZOw9ResSF+z8tfsyTWZ4eVs/tXRRA4yHYqH1b8xrz8Xo+nuNRJPE/ufKx6V9J0bZ+vnVygPODPIwOSZ+lspkkrLf8aNgu+RosEB7WC4W8M7vxHTpZTZWqdB0g9STZfH6avtl+df1dJFRJNdLpO6CSlX9PqlcVYo1EYybhRe0T4jeS0aPMvhoIdFofAgTJ1dm5B+weWYKPZKA891+lwNlqW43LWpdC1VH7ABA83VAJzmQ9br72cww6nO5tWRHR8UiH8Y5k8tsrA4tWQrk3N5ut2+2XN96OV7MkiEW8RSuF4LMjQfvpl3O1qtIyPGzTM0mJnvs3mlNo9lswYJTS/6ACpf7+t3fxcXFbKi3/GYOF/AOo36xtPJdf4ef1/G8Yr3r2m/UWbCgAMwBiJnz5thLpCM14kTvEYHohMAOgpBe7Jt1kDTJQFArQCREgIBmwPaBBvHHYGidhWQNgMYGEu4ASPQY/5gAeWDxzMDhSuHj89Ahh47Pgf7YdCjPu5b0GKngOFxQCGqUCIfhv/uWfARf+BM9wCAlnGF6Dfx59Eh1SsFwLQJZBh/iBF/4IT2lXs7QlcLGL8wqLBB2MBHyubLsSDZOv9gXAXSGA+h1T6QNWADkWGIRpVGGfBaBABG0aCGHBhcxCHPLAFaSCF2CABHuAG0gEoA7XQBtXD4Q0QBFng0KQTZREaJw7SPrwZmkAOmlDUQnDCs5YmDAohA8xgprfGURYTx2VxEKrEPuJ0IRWiCn6beNbwRGiGFugdR61fqwY6QA6+UAF+iaihDVSzcuh1KKSh01FVyIDuLcuZt7C5I0OnR2UVpSHYMz00hNnypebax+BIiANdDpWkHhwQjQAAAAA=); } </style></defs><rect x="0" y="0" width="1081.6370313640625" height="772.25" fill="#ffffff"></rect><g stroke-linecap="round" transform="translate(14.490141898123547 38.5) rotate(0 50 67)"><path d="M0 0 C25.66 0.7, 51.37 1.35, 100 0 M0 0 C24.31 -0.36, 48.98 -0.01, 100 0 M100 0 C100.25 29.92, 99.83 56.31, 100 134 M100 0 C101.85 34.28, 101.22 68.56, 100 134 M100 134 C79.06 133.86, 56.21 136.15, 0 134 M100 134 C65.44 132.33, 31.25 132.83, 0 134 M0 134 C0.3 88.25, -0.78 48.12, 0 0 M0 134 C-1.61 98.19, -2.28 60.29, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g stroke-linecap="round"><g transform="translate(13.490141898123547 83.5) rotate(0 50.5 0.5)"><path d="M-1.04 0.59 C15.95 0.49, 84.78 -0.22, 101.69 -0.11 M0.61 -0.14 C17.53 -0.18, 84.66 0.37, 101.11 0.84" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round"><g transform="translate(14.990141898123547 128) rotate(0 50.5 0.5)"><path d="M0.39 0.38 C17.24 0.29, 84.83 0.36, 101.56 0.38 M-0.87 -0.47 C15.83 -0.48, 84.11 1.26, 100.91 1.59" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(236.74014189812357 76) rotate(0 59 47)"><path d="M0 0 C38.66 0.54, 74.91 -1.33, 118 0 M0 0 C39.08 -1.01, 79 -1.36, 118 0 M118 0 C118.44 24.68, 117.96 48.68, 118 94 M118 0 C117.52 19.38, 118.21 40.02, 118 94 M118 94 C75.19 94.43, 34.15 92.27, 0 94 M118 94 C77.82 94.84, 36.63 93.55, 0 94 M0 94 C-0.41 67.76, 0.15 44.89, 0 0 M0 94 C-1.14 63.88, 0.01 33.28, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(307.74014189812357 77) rotate(0 22.649986267089844 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Heap</text></g><g transform="translate(31.740141898123547 10) rotate(0 28.91998291015625 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Stack</text></g><g stroke-linecap="round" transform="translate(246.74014189812357 131) rotate(0 27.5 15)"><path d="M0 0 C13.07 -0.5, 24.09 -0.47, 55 0 M0 0 C20.86 0, 40.47 -0.2, 55 0 M55 0 C54.71 11.37, 53.62 22.77, 55 30 M55 0 C55.08 7.66, 54.81 15.23, 55 30 M55 30 C33.78 28.33, 16.56 30.71, 0 30 M55 30 C32.6 31.02, 12.05 30.79, 0 30 M0 30 C-1.55 19.6, 1.06 11.72, 0 0 M0 30 C-0.39 19.09, 1.08 8.35, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(425.48199552483726 66.08986759809187) rotate(0 60.999977111816406 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#f08c00" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">0: new #2</text></g><g transform="translate(390.7271973769546 101.93924394222455) rotate(0 244.56980895996094 37.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">The `new` instruction opens a space in the heap </text><text x="0" y="42.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">and a (ref) reference returned will be pushed </text><text x="0" y="67.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">onto the top of the stack.</text></g><g transform="translate(49.740141898123575 49) rotate(0 15.269989013671875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">ref</text></g><g stroke-linecap="round"><g transform="translate(92.74014189812357 68.11313063217625) rotate(0 82.39279176369308 37.4946599132646)"><path d="M-0.89 0.14 C26.71 12.72, 136.76 63.71, 164.57 76.09 M0.85 -0.83 C28.35 11.39, 136.01 61.83, 163.51 74.55" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(92.74014189812357 68.11313063217625) rotate(0 82.39279176369308 37.4946599132646)"><path d="M138.6 72.39 C144.3 72.68, 151.34 75.49, 163.51 74.55 M138.6 72.39 C145.59 72.46, 151.07 72.86, 163.51 74.55" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(92.74014189812357 68.11313063217625) rotate(0 82.39279176369308 37.4946599132646)"><path d="M145.82 56.88 C150.02 60.52, 155.49 66.71, 163.51 74.55 M145.82 56.88 C150.92 60.89, 154.56 65.24, 163.51 74.55" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(11.115141898123547 221.25) rotate(0 50 67)"><path d="M0 0 C29.44 -0.7, 55.63 -0.91, 100 0 M0 0 C36.16 0.91, 72.68 1.15, 100 0 M100 0 C97.91 46.56, 99.03 90.25, 100 134 M100 0 C100.41 37.51, 99.77 72.39, 100 134 M100 134 C67.63 134.86, 33.94 131.36, 0 134 M100 134 C77.67 134.39, 57.98 134.63, 0 134 M0 134 C2.75 104.98, 2.63 78.39, 0 0 M0 134 C-1.83 83.55, 0.09 33.35, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g stroke-linecap="round"><g transform="translate(10.115141898123547 266.25) rotate(0 50.5 0.5)"><path d="M0.88 -0.71 C17.85 -0.59, 84 -0.18, 100.81 0.16 M-0.12 1.53 C16.77 1.83, 82.84 1.65, 99.77 1.26" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round"><g transform="translate(11.615141898123547 310.75) rotate(0 50.5 0.5)"><path d="M-0.71 -0.19 C16.08 -0.04, 83.15 1.77, 100.16 1.78 M1.11 -1.33 C18.33 -1.6, 85.82 -0.26, 102.43 0.07" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(233.36514189812357 258.75) rotate(0 59 47)"><path d="M0 0 C42.67 1.49, 88.71 -1.62, 118 0 M0 0 C31.27 0.9, 61.87 -0.44, 118 0 M118 0 C116.3 18.86, 118.41 37.34, 118 94 M118 0 C117.98 31.1, 118.45 60.79, 118 94 M118 94 C80.55 91.6, 48.08 93.72, 0 94 M118 94 C92.77 94.22, 65.9 94.37, 0 94 M0 94 C-0.01 59.36, 2.06 21.49, 0 0 M0 94 C0.08 75.51, 0.38 55.61, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(304.36514189812357 259.75) rotate(0 22.649986267089844 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Heap</text></g><g transform="translate(28.365141898123547 192.75) rotate(0 28.91998291015625 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Stack</text></g><g stroke-linecap="round" transform="translate(243.36514189812357 313.75) rotate(0 27.5 15)"><path d="M0 0 C10.84 -0.9, 25.31 -0.94, 55 0 M0 0 C16.97 -0.85, 35.99 -0.29, 55 0 M55 0 C53.47 6.68, 56.7 11.52, 55 30 M55 0 C54.14 6.46, 55.97 12.28, 55 30 M55 30 C43.64 28.78, 31.78 32.41, 0 30 M55 30 C35.4 30.41, 16.62 30.35, 0 30 M0 30 C-0.46 20.24, -0.55 16.21, 0 0 M0 30 C0.03 21.98, 0.66 12.97, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(46.365141898123575 231.75) rotate(0 15.269989013671875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">ref</text></g><g stroke-linecap="round"><g transform="translate(89.36514189812357 250.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M-0.45 0.01 C26.88 12.74, 136.69 62.83, 164.32 75.29 M1.52 -1.03 C28.62 11.41, 135.91 60.48, 163.13 73.32" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(89.36514189812357 250.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M138.22 71.2 C146.41 71.22, 155.08 73.57, 163.13 73.32 M138.22 71.2 C145.51 71.66, 151.38 72.37, 163.13 73.32" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(89.36514189812357 250.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M145.41 55.69 C151.09 60.78, 157.4 68.23, 163.13 73.32 M145.41 55.69 C150.52 60.48, 154.35 65.6, 163.13 73.32" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g transform="translate(433.1110687114803 250) rotate(0 31.09998321533203 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#f08c00" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">3: dup</text></g><g transform="translate(393.14524620608216 289.2974478460208) rotate(0 298.8397216796875 25)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">The `dup` instruction duplicates the top-of-stack reference</text><text x="0" y="42.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">and pushes onto the top of the stack</text></g><g transform="translate(45.240141898123575 276.5) rotate(0 15.269989013671875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">ref</text></g><g stroke-linecap="round"><g transform="translate(81.74014189812357 292) rotate(0 87.5 22)"><path d="M0.79 1.12 C30.02 8.49, 145.53 36.27, 174.71 43.52 M-0.26 0.67 C28.85 8.25, 144.31 37.82, 173.62 44.81" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(81.74014189812357 292) rotate(0 87.5 22)"><path d="M148.75 47.44 C156.66 46.16, 160.01 47.45, 173.62 44.81 M148.75 47.44 C156.56 46.86, 166.93 46.31, 173.62 44.81" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(81.74014189812357 292) rotate(0 87.5 22)"><path d="M152.88 30.84 C159.7 33.61, 162.05 38.92, 173.62 44.81 M152.88 30.84 C159.34 36.09, 168.26 41.38, 173.62 44.81" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(12.115141898123547 411.25) rotate(0 50 67)"><path d="M0 0 C19.69 1.07, 41.15 -0.13, 100 0 M0 0 C21.49 0.15, 42.58 -0.64, 100 0 M100 0 C100.48 53.16, 99.2 103.32, 100 134 M100 0 C101.39 46.8, 101.78 92.67, 100 134 M100 134 C66.76 133, 32.53 133.77, 0 134 M100 134 C67.78 134.08, 37 132.29, 0 134 M0 134 C1.53 90.27, 0.18 45.61, 0 0 M0 134 C-1.97 100.65, -0.29 66.6, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g stroke-linecap="round"><g transform="translate(11.115141898123547 456.25) rotate(0 50.5 0.5)"><path d="M-0.49 0.94 C16.4 1.04, 84.35 1.01, 101.08 1.22 M1.45 0.39 C18.21 0.05, 83.39 -0.8, 100.18 -0.79" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round"><g transform="translate(12.615141898123547 500.75) rotate(0 50.5 0.5)"><path d="M0.94 0.08 C17.71 0.15, 84.34 -0.33, 101.22 -0.1 M-0.02 -0.92 C16.56 -0.7, 83.37 0.81, 100.38 0.86" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(234.36514189812357 448.75) rotate(0 59 47)"><path d="M0 0 C30.93 -1.92, 63.12 0.7, 118 0 M0 0 C42.96 -0.18, 87.17 -0.8, 118 0 M118 0 C116.75 26.54, 120.01 50.16, 118 94 M118 0 C118.85 31.12, 118.03 61.86, 118 94 M118 94 C74.04 95.33, 32.57 93.16, 0 94 M118 94 C87.18 94.96, 57.79 94.75, 0 94 M0 94 C0.48 58.73, 1.28 23.94, 0 0 M0 94 C-0.24 73.85, 0.19 53.27, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(305.36514189812357 449.75) rotate(0 22.649986267089844 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Heap</text></g><g transform="translate(29.365141898123547 382.75) rotate(0 28.91998291015625 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Stack</text></g><g stroke-linecap="round" transform="translate(244.36514189812357 503.75) rotate(0 27.5 15)"><path d="M0 0 C18.28 0.78, 36.09 1.31, 55 0 M0 0 C15.43 -0.69, 30.64 -1.33, 55 0 M55 0 C54.01 7.15, 56.34 14.56, 55 30 M55 0 C55.66 10.51, 54.37 20.52, 55 30 M55 30 C38.77 29.36, 28.15 31.33, 0 30 M55 30 C43.04 30.56, 31.3 29.88, 0 30 M0 30 C-1.28 17.98, 1.03 10.96, 0 0 M0 30 C0.16 20.09, 0.38 10.71, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(47.365141898123575 421.75) rotate(0 15.269989013671875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">ref</text></g><g stroke-linecap="round"><g transform="translate(90.36514189812357 440.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M0.79 0.65 C28.24 13.02, 138.38 62.15, 165.9 74.69 M-0.25 -0.05 C27.04 12.46, 137.87 63.73, 165.53 76.07" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(90.36514189812357 440.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M140.61 74.11 C151.65 76.58, 160.01 77.34, 165.53 76.07 M140.61 74.11 C150.35 74.01, 158.58 76.1, 165.53 76.07" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(90.36514189812357 440.8631306321763) rotate(0 82.39279176369308 37.4946599132646)"><path d="M147.7 58.55 C155.97 67.28, 161.5 74.25, 165.53 76.07 M147.7 58.55 C154.81 64.28, 160.38 72.23, 165.53 76.07" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g transform="translate(419.6149755175017 430.81225042906715) rotate(0 94.59992218017578 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#f08c00" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">4: invokespecial #3</text></g><g transform="translate(387.0312628834218 465.7106415908338) rotate(0 317.7896728515625 37.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">The `invokespecial` instruction pops the top-of-stack reference </text><text x="0" y="42.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">and the just-allocated space will be initialized </text><text x="0" y="67.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">through invoking constructor</text></g><g stroke-linecap="round" transform="translate(18.115141898123547 628.25) rotate(0 50 67)"><path d="M0 0 C27.21 -2.16, 56.06 -0.53, 100 0 M0 0 C25.49 1.09, 50.43 -0.09, 100 0 M100 0 C101.25 34.81, 101.43 67.17, 100 134 M100 0 C99.98 48.89, 100.22 100.35, 100 134 M100 134 C64.98 132.82, 31.63 132.48, 0 134 M100 134 C78.36 135.42, 58.06 134.6, 0 134 M0 134 C-0.85 88.88, 0.92 45.52, 0 0 M0 134 C0.5 81.08, 1.13 28.5, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g stroke-linecap="round"><g transform="translate(17.115141898123547 673.25) rotate(0 50.5 0.5)"><path d="M-0.72 -0.7 C15.86 -0.68, 83.7 1.05, 100.55 1.27 M1.11 1.55 C17.4 1.69, 83 -0.74, 99.37 -0.7" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round"><g transform="translate(18.615141898123547 717.75) rotate(0 50.5 0.5)"><path d="M-0.7 -0.45 C15.98 -0.26, 84.39 0.22, 101.27 0.42 M1.14 -1.73 C17.58 -1.32, 84.05 1.03, 100.47 1.65" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g stroke-linecap="round" transform="translate(240.36514189812357 665.75) rotate(0 59 47)"><path d="M0 0 C28.82 -0.53, 56.11 0.05, 118 0 M0 0 C39.17 -0.63, 79.53 0.51, 118 0 M118 0 C117.68 31.64, 118.62 60.76, 118 94 M118 0 C118.17 27.15, 117.38 53.6, 118 94 M118 94 C81.3 93.08, 48.76 96.11, 0 94 M118 94 C90.15 94.37, 62.42 93.61, 0 94 M0 94 C0.76 71.07, -0.58 44.86, 0 0 M0 94 C0.1 67.58, 0.86 39.02, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(311.36514189812357 666.75) rotate(0 22.649986267089844 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Heap</text></g><g transform="translate(35.36514189812355 599.75) rotate(0 28.91998291015625 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">Stack</text></g><g stroke-linecap="round" transform="translate(250.36514189812357 720.75) rotate(0 27.5 15)"><path d="M0 0 C17.37 0.86, 37.31 0.44, 55 0 M0 0 C15.61 -0.12, 30.33 -0.03, 55 0 M55 0 C55.53 7.58, 53.57 15.97, 55 30 M55 0 C55.43 11.77, 54.42 24.38, 55 30 M55 30 C44.69 28.87, 33.53 30.24, 0 30 M55 30 C38.16 29.69, 21.87 30.57, 0 30 M0 30 C0.17 20.13, -0.72 11.72, 0 0 M0 30 C-0.63 22.11, -0.38 13.21, 0 0" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(97.36514189812357 582.75) rotate(0 15.269989013671875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">ref</text></g><g stroke-linecap="round"><g transform="translate(127.65758538749535 601.4438513166059) rotate(0 63.746570019007194 60.704299571049816)"><path d="M0.41 1.07 C21.75 21.29, 106.57 100.89, 127.65 121.07 M-0.83 0.59 C20.4 21.01, 105.67 102.5, 126.79 122.43" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(127.65758538749535 601.4438513166059) rotate(0 63.746570019007194 60.704299571049816)"><path d="M103.87 112.44 C111.81 115.32, 115.62 116.8, 126.79 122.43 M103.87 112.44 C112.66 116.31, 120.14 120.32, 126.79 122.43" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(127.65758538749535 601.4438513166059) rotate(0 63.746570019007194 60.704299571049816)"><path d="M115.66 100.05 C120.4 106.3, 121.04 111.12, 126.79 122.43 M115.66 100.05 C120.26 108.42, 123.49 116.91, 126.79 122.43" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask><g transform="translate(428.2009363095722 633.4493379904595) rotate(0 56.8299560546875 12.5)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#f08c00" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">7: astore_1</text></g><g transform="translate(389.6775587078126 675.0892343538062) rotate(0 340.979736328125 25)"><text x="0" y="17.619999999999997" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">The top-of-stack reference is popped and assigned to </text><text x="0" y="42.62" font-family="Virgil, Segoe UI Emoji" font-size="20px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">the element (`newTest`) at the position 1 of the LocalVariableTable</text></g><g transform="translate(234.74014189812357 570) rotate(0 78.76631927490234 42.39130434782609)"><text x="0" y="14.938695652173916" font-family="Virgil, Segoe UI Emoji" font-size="16.956521739130437px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">LocalVariableTable</text><text x="0" y="36.134347826086966" font-family="Virgil, Segoe UI Emoji" font-size="16.956521739130437px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">0 args</text><text x="0" y="57.33000000000001" font-family="Virgil, Segoe UI Emoji" font-size="16.956521739130437px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic">1 newTest</text><text x="0" y="78.52565217391306" font-family="Virgil, Segoe UI Emoji" font-size="16.956521739130437px" fill="#000000" text-anchor="start" style="white-space: pre;" direction="ltr" dominant-baseline="alphabetic"></text></g><g stroke-linecap="round"><g transform="translate(230.60415477559212 622.0730316488514) rotate(0 -54.1325581609058 -16.281023290192607)"><path d="M0.67 -0.55 C-17.37 -6.08, -88.99 -27.43, -107.21 -32.79 M-0.43 1.77 C-18.63 -3.6, -89.41 -25.84, -107.61 -31.38" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(230.60415477559212 622.0730316488514) rotate(0 -54.1325581609058 -16.281023290192607)"><path d="M-82.64 -32.6 C-93.2 -30.23, -102.3 -32.13, -107.61 -31.38 M-82.64 -32.6 C-90.05 -31.68, -96.14 -32.09, -107.61 -31.38" stroke="#000000" stroke-width="1" fill="none"></path></g><g transform="translate(230.60415477559212 622.0730316488514) rotate(0 -54.1325581609058 -16.281023290192607)"><path d="M-87.7 -16.26 C-96.35 -20.23, -103.5 -28.44, -107.61 -31.38 M-87.7 -16.26 C-93.61 -20.09, -98.25 -25.2, -107.61 -31.38" stroke="#000000" stroke-width="1" fill="none"></path></g></g><mask></mask></svg></div>
<p><code>dup</code> 指令需要复制栈顶元素的原因是因为下一步的 <code>invokespecial</code> 需要执行默认构造函数，这将从栈顶弹出一个引用。如果没有 <code>dup</code> 来复制栈顶元素，在执行 <code>invokespecial</code> 后将导致栈为空，从而导致新创建的对象丢失。</p>
<p>这解释了为什么 <code>new</code> 不是一个原子操作。尽管在 Java 代码中只有一行，但在字节码层面，它转化为四个关键指令操作。由于指令重排，<code>new</code> 中的三个步骤可以被重新排序。在多线程环境中，这可能导致上述单例模式的问题。因此，有必要在 <code>instance</code> 字段上添加 <code>volatile</code> 以防止重排。</p>
<h2 id="15-懒汉单例-双重检查锁定dcl"><a class="markdownIt-Anchor" href="#15-懒汉单例-双重检查锁定dcl"></a> 1.5. 懒汉单例 - 双重检查锁定（DCL）</h2>
<p>双重检查锁定是最推荐的懒汉初始化单例模式，确保了<span style="background:#fff88f">线程安全</span>，并实现了<span style="background:#fff88f">延迟加载</span>。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.5. 懒汉单例 - 双重检查锁定（DCL）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1. 懒汉初始化</span></span><br><span class="line"><span class="comment"> * 2. 可以通过双重检查锁定（DCL）确保线程安全</span></span><br><span class="line"><span class="comment"> * 3. 可以减少锁定开销</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 1. 更复杂</span></span><br><span class="line"><span class="comment"> * 2. 面对大量初始 `getInstance()` 请求时，可能会影响其性能</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 当单例类持有大量资源时使用。</span></span><br><span class="line"><span class="comment"> * 2. 当我们希望延迟创建单例实例直到真正需要时使用。</span></span><br><span class="line"><span class="comment"> * 3. 当我们同时考虑性能和懒汉初始化时使用。</span></span><br><span class="line"><span class="comment"> * 4. 当单例类属于轻量级或总是需被使用时，该场景可考虑可避免使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDoubleCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingletonDoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自己创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDoubleCheck</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDoubleCheck <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDoubleCheck.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDoubleCheck</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="151-对懒汉单例-双重检查锁定的反射攻击"><a class="markdownIt-Anchor" href="#151-对懒汉单例-双重检查锁定的反射攻击"></a> 1.5.1. 对“懒汉单例 - 双重检查锁定”的反射攻击</h3>
<p>通常，为了避免反射攻击，我们通常在私有构造函数中添加检查，以查看 <code>instance</code> 字段是否为 null。如果 <code>instance</code> 不为 null，我们可以假设这个单例类已经创建了它的对象，并抛出异常以防止反射攻击。</p>
<p>然而，它容易受到反射攻击，这可能破坏预期的单例行为。我们来看以下两种情况：</p>
<ul>
<li>情况 1 (√)：如果我们先调用 <code>getInstance()</code> 然后调用 <code>constructor.newInstance()</code>，将抛出错误以防止反射攻击。</li>
<li>情况 2 (×)：如果我们先调用 <code>constructor.newInstance()</code> 然后调用 <code>getInstance()</code>，我们将获得两个不同的实例，导致单例模式破裂。</li>
</ul>
<p>因此，懒汉单例无法在所有情况下防止反射攻击。具体原因如下：</p>
<ol>
<li>反射允许访问私有构造函数。攻击者可以使用反射机制绕过私有构造函数，创建单例类的新实例。</li>
<li>它缺乏任何固有机制来检查通过反射访问时单例类的实例是否已经存在。</li>
<li>在私有构造函数中抛出异常以防止反射攻击并不是一个万无一失的计划，因为攻击者仍然可以操控实例创建过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDoubleCheckReflectionProof</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingletonDoubleCheckReflectionProof instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自己创建实例，但不能防止构造函数反射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDoubleCheckReflectionProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不能防止反射攻击：第一次使用反射调用将仍然成功，但后续尝试将失败。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDoubleCheckReflectionProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDoubleCheckReflectionProof.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDoubleCheckReflectionProof</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="152-对懒汉单例-双重检查锁定的序列化攻击"><a class="markdownIt-Anchor" href="#152-对懒汉单例-双重检查锁定的序列化攻击"></a> 1.5.2. 对“懒汉单例 - 双重检查锁定”的序列化攻击</h3>
<p>序列化和反序列化一个类需要实现 <code>java.io.Serializable</code>，否则将抛出 <code>java.io.NotSerializableException</code>。序列化和反序列化的一般过程：</p>
<ol>
<li>序列化单例类以生成序列化文件。</li>
<li>读取序列化文件通过反序列化获取单例类的实例。</li>
<li>比较序列化实例和反序列化实例是否相同。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类必须实现 `java.io.Serializable` 以避免抛出 `java.io.NotSerializableException`。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDoubleCheckSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingletonDoubleCheckSerialization instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自己创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDoubleCheckSerialization</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不能在所有情况下防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDoubleCheckSerialization <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDoubleCheckSerialization.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDoubleCheckSerialization</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们将单例类序列化以生成序列化文件 -&gt; 读取序列化文件并通过反序列化获取单例类的实例 -&gt; 反序列化的实例与 <code>getInstance()</code> 的实例不相同，从而破坏单例模式。以下是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSerializationAttackOnLazySingletonDoubleCheckSerialization</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LazySingletonDoubleCheckSerialization</span> <span class="variable">instance</span> <span class="operator">=</span> LazySingletonDoubleCheckSerialization.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">serializedClassPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;TestSerialization-&quot;</span> + LazySingletonDoubleCheckSerialization.class.getSimpleName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化：</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(serializedClassPath))) &#123;</span><br><span class="line">        objectOutputStream.writeObject(instance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化：构造函数将不会被调用，数据将通过从字节流读取来初始化。</span></span><br><span class="line">    LazySingletonDoubleCheckSerialization testSerializableInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(serializedClassPath))) &#123;</span><br><span class="line">        testSerializableInstance = ((LazySingletonDoubleCheckSerialization) objectInputStream.readObject());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assertions.assertSame(instance, testSerializableInstance); <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述反序列化生成新对象的原因是序列化有其自己的机制。它<font color="#00b050">读取字节流数据而不调用构造函数</font>。对于非枚举单例，为防止序列化攻击，需要添加版本号，如 <code>private static final long serialVersionUID = -1L;</code>，并实现 <code>readResolve()</code> 方法，返回类的实例。这样就可以得到相同的对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingletonDoubleCheckSerializationProof</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要用于版本控制，确保序列化和反序列化类版本之间的兼容性。</span></span><br><span class="line"><span class="comment">     * 如果在序列化时未添加 `serialVersionUID`，将根据当前类数据自动生成一个版本号。</span></span><br><span class="line"><span class="comment">     * 反序列化时，也会自动生成一个版本号。</span></span><br><span class="line"><span class="comment">     * 如果两个版本号不匹配（例如，类内容在反序列化之前被修改），将报告以下错误：</span></span><br><span class="line"><span class="comment">     * `java.io.InvalidClassException: local class incompatible: stream classdesc serialVersionUID = -4190675925334731018, local class serialVersionUID = 1437610846000386433</span></span><br><span class="line"><span class="comment">     * 指定 `serialVersionUID` 可以解决此问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingletonDoubleCheckSerializationProof instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自己创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDoubleCheckSerializationProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不能在所有情况下防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDoubleCheckSerializationProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDoubleCheckSerializationProof.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDoubleCheckSerializationProof</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于非枚举单例模式，当面临序列化攻击时，必须实现 `readResolve()` 方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 反序列化实例是相同的，返回该实例</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分析反序列化的源代码：<code>objectInputStream.readObject()</code> -&gt; <code>readObject(Object.class)</code> -&gt; <code>Object obj = readObject0(type, false);</code> -&gt; 在 TC_OBJECT 的情况下：<code>readOrdinaryObject(unshared)</code>。</p>
<p><code>readOrdinaryObject(unshared)</code> 的关键点是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// hasReadResolveMethod：检查当前类是否有 `readResolve()` 方法。</span></span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用当前类的 `readResolve()` 方法。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// 过滤替换对象</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 `readResolve()` 返回的 `rep` 被赋值给 `obj`。</span></span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasReadResolveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="comment">// 如果 `readResolveMethod` 不为 null，表示当前类有 `readResolve()` 方法。</span></span><br><span class="line">    <span class="keyword">return</span> (readResolveMethod != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前类的 `readResolve()` 方法，并将其赋值给 `readResolveMethod` 变量</span></span><br><span class="line">    readResolveMethod = getInheritableMethod(cl, <span class="string">&quot;readResolve&quot;</span>, <span class="literal">null</span>, Object.class);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="153-完美版的懒汉单例-双重检查锁定"><a class="markdownIt-Anchor" href="#153-完美版的懒汉单例-双重检查锁定"></a> 1.5.3. 完美版的“懒汉单例 - 双重检查锁定”</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉单例 - 双重检查锁定（DCL）：完美版</span></span><br><span class="line"><span class="comment"> * 1. 使用 volatile + DCL 来保证线程安全并减少同步的使用</span></span><br><span class="line"><span class="comment"> * 2. 尝试使用私有构造函数检查来防止反射攻击，但不能在所有情况下保证</span></span><br><span class="line"><span class="comment"> * 3. 使用定义的 serialVersionUID 和 readResolve() 来防止序列化攻击</span></span><br><span class="line"><span class="comment"> * 4. 重写 clone() 方法以防止克隆攻击</span></span><br><span class="line"><span class="comment"> * 5. 使用 final 类来防止子类化，避免任何子类破坏单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LazySingletonDoubleCheckPerfect</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确定义 `serialVersionUID` 可以避免潜在的兼容性问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 以防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingletonDoubleCheckPerfect instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingletonDoubleCheckPerfect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 无法在所有情况下防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingletonDoubleCheckPerfect <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonDoubleCheckPerfect.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingletonDoubleCheckPerfect</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止序列化攻击</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化期间：返回现有实例，而不是创建新实例。</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// (1) 抛出异常以防止克隆</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;Cloning of this singleton instance is not allowed&quot;</span>);</span><br><span class="line">        <span class="comment">// (2) 或者直接从克隆方法返回相同的实例</span></span><br><span class="line">        <span class="comment">//return getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-饿汉式单例"><a class="markdownIt-Anchor" href="#2-饿汉式单例"></a> 2. 饿汉式单例</h1>
<p>饿汉式初始化模式在类加载时完成初始化，依赖于<font color="#00b050">类加载机制</font>来确保单例行为而无需特地人为加锁，从而实现更高的执行效率。然而，由于在类加载时进行实例化，它缺乏延迟加载的优势。如果实例未被使用，它将被不必要地实例化，导致资源浪费。</p>
<p>在以下两个饿汉式单例的例子中，它们都比懒汉式单例简单得多。这两种模式都利用了 JVM 的类加载机制来确保实例的唯一性。初始化只发生一次，并且 JVM 会同步类加载过程。</p>
<p>类加载过程包括：</p>
<ol>
<li><strong>加载</strong>：JVM 定位并将类文件的字节码加载到内存中，生成相应的类数据结构。</li>
<li><strong>链接</strong>：<strong>验证</strong>（验证加载的字节码的正确性）→ <strong>准备</strong>（将静态字段初始化为默认值）→ <strong>解析</strong>（将类文件中的符号引用解析为实际引用）</li>
<li><strong>初始化</strong>：类中的<font color="#00b050">静态初始化器</font>和<font color="#00b050">静态代码块</font>在<code>&lt;clinit&gt;</code>中执行，此过程仅在类首次被使用时发生，例如创建实例或调用静态方法时。</li>
<li><strong>使用</strong>：类被加载和初始化后，可以创建其实例，调用其方法以及访问其字段。</li>
<li><strong>卸载</strong>：当类及其相关的类加载器不再使用且可以被垃圾回收时，类会从内存中移除。</li>
</ol>
<p>由于 <code>instance</code> 变量是静态成员变量，其实例化发生在类加载的初始化阶段。此阶段涉及执行类构造器 <code>&lt;clinit&gt;()</code> 方法，编译器会自动收集类中的所有静态变量和静态代码块。因此，<code>private static final EagerSingletonStaticConstant instance = new EagerSingletonStaticConstant();</code> 和 <code> static &#123; instance = new EagerSingletonStaticBlock(); &#125;</code> 也在此方法中执行。JVM 确保类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中是同步的，从而保证了线程安全。</p>
<details class="custom-callout tip" open><summary class="callout-title"><div class="callout-icon"></div><div>Tip</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>有些人可能会困惑为什么饿汉式单例更浪费资源。他们可能会想：“当那个饿汉式单例类从未使用时，似乎没有调用类的构造函数。”</p>
<p>实际上，这种情况更多地出现在调用类的其他方法时，而不是调用<code>getInstance()</code>方法。对于饿汉式单例，即使你不获取该单例的实例，仅仅是调用类的其他方法，也会由于类加载机制触发类的创建。但对于懒汉式单例，它不会触发类的创建，而只是执行该其他方法。</p>
<p>有关更多详细信息，请参阅此示例：<a target="_blank" rel="noopener" href="https://github.com/sissilab/DesignPattern-Lab/blob/master/src/main/java/com/sissilab/dp/ox1_creational/ox11_singleton/EagerSingletonWastingReason.java">EagerSingletonWastingReason.java at sissilab/DesignPattern-Lab (github.com)</a>。</p>
</div>
</details><h2 id="21-饿汉式单例-静态常量"><a class="markdownIt-Anchor" href="#21-饿汉式单例-静态常量"></a> 2.1. 饿汉式单例 - 静态常量</h2>
<p>这种实现非常简单，但可能会导致资源浪费，因为类的实例总是被创建，无论是否需要。而且在类创建期间处理异常也不容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.1. 饿汉式单例 - 静态常量</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1. 基于类加载机制保证线程安全，不需要同步操作</span></span><br><span class="line"><span class="comment"> * 2. 实现简单易懂，无需额外的代码来处理懒加载或同步机制</span></span><br><span class="line"><span class="comment"> * 3. 在 `getInstance()` 时没有性能开销，因为实例是在类加载时创建的</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 1. 可能会由于提前创建实例而浪费资源，尤其是对于拥有大缓存或数据库连接的重量级单例类</span></span><br><span class="line"><span class="comment"> * 2. 缺乏懒加载</span></span><br><span class="line"><span class="comment"> * 3. 使用静态常量时，处理类创建期间的异常不灵活</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 当单例类相对轻量时使用。</span></span><br><span class="line"><span class="comment"> * 2. 当单例类在应用程序生命周期中频繁使用时使用。</span></span><br><span class="line"><span class="comment"> * 3. 当懒加载更合适时避免使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在类加载时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingletonStaticConstant</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticConstant</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：禁止用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticConstant</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticConstant <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了饿汉式单例模式的简单实现，它依赖于静态常量来保证实例的唯一性和线程安全性。</p>
<h3 id="211-对饿汉式单例-静态常量的反射攻击"><a class="markdownIt-Anchor" href="#211-对饿汉式单例-静态常量的反射攻击"></a> 2.1.1. 对“饿汉式单例 - 静态常量”的反射攻击</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticConstantReflectionProof</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在类加载时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingletonStaticConstantReflectionProof</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticConstantReflectionProof</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：禁止用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticConstantReflectionProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticConstantReflectionProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="212-对饿汉式单例-静态常量的序列化攻击"><a class="markdownIt-Anchor" href="#212-对饿汉式单例-静态常量的序列化攻击"></a> 2.1.2. 对“饿汉式单例 - 静态常量”的序列化攻击</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticConstantSerializationProof</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式定义 `serialVersionUID`，以避免潜在的不兼容问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在类加载时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingletonStaticConstantSerializationProof</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticConstantSerializationProof</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：禁止用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticConstantSerializationProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticConstantSerializationProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止反序列化时创建新实例</span></span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化过程中：返回现有的实例，而不是创建新实例</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="213-完美版的饿汉式单例-静态常量"><a class="markdownIt-Anchor" href="#213-完美版的饿汉式单例-静态常量"></a> 2.1.3. 完美版的“饿汉式单例 - 静态常量”</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例 - 静态常量：完美版本</span></span><br><span class="line"><span class="comment"> * 1. 使用静态常量基于类加载机制创建单例实例</span></span><br><span class="line"><span class="comment"> * 2. 尝试使用私有构造函数检查来防止反射攻击，但无法在所有情况下保证</span></span><br><span class="line"><span class="comment"> * 3. 使用定义的 serialVersionUID 和 readResolve() 来防止序列化攻击</span></span><br><span class="line"><span class="comment"> * 4. 重写 clone() 以防止克隆攻击</span></span><br><span class="line"><span class="comment"> * 5. 使用 final 类以防止子类化，避免任何子类破坏单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EagerSingletonStaticConstantPerfect</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式定义 `serialVersionUID` 以避免潜在的不兼容问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在类加载时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingletonStaticConstantPerfect</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticConstantPerfect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：禁止用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticConstantPerfect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 无法在所有情况下防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticConstantPerfect <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止序列化攻击</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化过程中：返回现有的实例，而不是创建新实例</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// (1) 抛出异常以防止克隆</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;Cloning of this singleton instance is not allowed&quot;</span>);</span><br><span class="line">        <span class="comment">// (2) 或者直接从clone方法返回相同的实例</span></span><br><span class="line">        <span class="comment">//return getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-饿汉式单例-静态块"><a class="markdownIt-Anchor" href="#22-饿汉式单例-静态块"></a> 2.2. 饿汉式单例 - 静态块</h2>
<p>使用静态块完成类实例化也可能由于类加载机制导致资源浪费。但在静态块中处理异常和执行更多操作会更容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.2. 饿汉式单例 - 静态块</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1. 可以基于类加载机制保证创建是线程安全的，无需同步</span></span><br><span class="line"><span class="comment"> * 2. 更直接且易于理解，无需额外代码来处理延迟初始化或同步机制</span></span><br><span class="line"><span class="comment"> * 3. 在 `getInstance()` 时没有性能开销，因为实例是在类加载时创建的</span></span><br><span class="line"><span class="comment"> * 4. 在创建过程中，静态块灵活地处理更复杂的逻辑或异常</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 1. 由于过早创建可能浪费资源，尤其是对于资源密集型的单例类，如大型缓存或数据库连接</span></span><br><span class="line"><span class="comment"> * 2. 缺乏延迟初始化</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 在单例类相对轻量时使用。</span></span><br><span class="line"><span class="comment"> * 2. 在应用程序生命周期中频繁需要单例类时使用。</span></span><br><span class="line"><span class="comment"> * 3. 在需要复杂初始化步骤时使用，因为静态块提供了灵活性来处理。</span></span><br><span class="line"><span class="comment"> * 4. 当延迟加载更可取时避免使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticBlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在类加载时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingletonStaticBlock instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态块中创建该单例类的实例</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticBlock</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：禁止用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticBlock <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="221-对饿汉式单例-静态块的反射攻击"><a class="markdownIt-Anchor" href="#221-对饿汉式单例-静态块的反射攻击"></a> 2.2.1. 对“饿汉式单例 - 静态块”的反射攻击</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticBlockReflectionProof</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在静态块中加载类时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingletonStaticBlockReflectionProof instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticBlockReflectionProof</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticBlockReflectionProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticBlockReflectionProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="222-对饿汉式单例-静态块的序列化攻击"><a class="markdownIt-Anchor" href="#222-对饿汉式单例-静态块的序列化攻击"></a> 2.2.2. 对“饿汉式单例 - 静态块”的序列化攻击</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingletonStaticBlockSerializationProof</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确定义 `serialVersionUID` 可以避免潜在的不兼容问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在静态块中加载类时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingletonStaticBlockSerializationProof instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticBlockSerializationProof</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticBlockSerializationProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticBlockSerializationProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止序列化攻击</span></span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化期间：返回现有实例，而不是创建一个新的实例。</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="223-完美版本的饿汉式单例-静态块"><a class="markdownIt-Anchor" href="#223-完美版本的饿汉式单例-静态块"></a> 2.2.3. 完美版本的“饿汉式单例 - 静态块”</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例 - 静态块：完美版本</span></span><br><span class="line"><span class="comment"> * 1. 使用静态块基于类加载机制创建单例实例</span></span><br><span class="line"><span class="comment"> * 2. 尝试使用私有构造函数检查以防止反射攻击，但在所有情况下无法保证</span></span><br><span class="line"><span class="comment"> * 3. 使用定义的 serialVersionUID 和 readResolve() 来防止序列化攻击</span></span><br><span class="line"><span class="comment"> * 4. 重写 clone() 方法以防止克隆攻击</span></span><br><span class="line"><span class="comment"> * 5. 使用 final 类防止子类化，避免任何子类破坏单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EagerSingletonStaticBlockPerfect</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确定义 `serialVersionUID` 可以避免潜在的不兼容问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：在加载类时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingletonStaticBlockPerfect instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">EagerSingletonStaticBlockPerfect</span>();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingletonStaticBlockPerfect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在所有情况下无法防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingletonStaticBlockPerfect <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止序列化攻击</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化期间：返回现有实例，而不是创建一个新的实例。</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// (1) 抛出异常以防止克隆</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;Cloning of this singleton instance is not allowed&quot;</span>);</span><br><span class="line">        <span class="comment">// (2) 或直接从克隆方法返回相同实例</span></span><br><span class="line">        <span class="comment">//return getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-静态内部类单例"><a class="markdownIt-Anchor" href="#3-静态内部类单例"></a> 3. 静态内部类单例</h1>
<p>静态内部类单例模式本质上也利用了类加载机制来确保线程安全。由于其特性，它可以保证类初始化仅在实际使用时触发，这也是一种懒加载的形式。</p>
<ul>
<li>与 <a href="#15-%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9Adcl">1.5. 懒汉单例 - 双重检查锁定（DCL）</a> 相比，这种模式也能实现类似的懒加载效果，但实现更简单。</li>
<li>与 <a href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B">2. 饿汉式单例</a> 相比，这种模式同样利用类加载机制来初始化并确保只有一个类实例。当类被加载时，饿汉式单例将被实例化，但静态内部类单例可能不会。这是因为实例只有在其静态内部类 <code>InstanceHolder</code> 被使用和加载时才会创建。因此，<code>StaticInnerClassSingleton</code> 的实例不会在方法 <code>getInstance()</code> 被调用之前创建，这样就实现了懒加载的效果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 静态内部类单例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1. 基于静态内部类特性实现懒加载</span></span><br><span class="line"><span class="comment"> * 2. 可以保证 `InstanceHolder` 类的静态初始化在类加载机制下的线程安全</span></span><br><span class="line"><span class="comment"> * 3. 避免了与 DCL 模式相关的同步开销</span></span><br><span class="line"><span class="comment"> * 4. 相比于 DCL 模式，相对更容易理解</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 1. 对于类创建过程中出现的异常处理不够灵活</span></span><br><span class="line"><span class="comment"> * 2. 由于类加载时机可能导致意外问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 当单例类持有大量资源时使用</span></span><br><span class="line"><span class="comment"> * 2. 当希望延迟单例实例的创建直到真正需要时使用</span></span><br><span class="line"><span class="comment"> * 3. 当需要复杂初始化步骤时避免使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类提供类的单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticInnerClassSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerClassSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有在这里才会触发 `InstanceHolder.instance` 的初始化</span></span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="31-对静态内部类单例的反射攻击"><a class="markdownIt-Anchor" href="#31-对静态内部类单例的反射攻击"></a> 3.1. 对“静态内部类单例”的反射攻击</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticInnerSingletonReflectionProof</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类提供类的单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticInnerSingletonReflectionProof</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerSingletonReflectionProof</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例，但无法防止构造函数的反射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerSingletonReflectionProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingletonReflectionProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有在这里才会触发 `InstanceHolder.instance` 的初始化。</span></span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32-对静态内部类单例的序列化攻击"><a class="markdownIt-Anchor" href="#32-对静态内部类单例的序列化攻击"></a> 3.2. 对“静态内部类单例”的序列化攻击</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticInnerSingletonSerializationProof</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在序列化过程中没有添加 `serialVersionUID`，版本号将根据当前类数据自动生成。</span></span><br><span class="line"><span class="comment">     * 在反序列化时，也会自动生成一个版本号。</span></span><br><span class="line"><span class="comment">     * 如果两个版本号不匹配（类内容在反序列化前被修改），则会报告以下错误：</span></span><br><span class="line"><span class="comment">     * `java.io.InvalidClassException: local class incompatible: stream classdesc serialVersionUID = -6193354024038071874, local class serialVersionUID = 3430229600994946531`</span></span><br><span class="line"><span class="comment">     * 指定一个 serialVersionUID 可以解决此问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类提供类的单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticInnerSingletonSerializationProof</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerSingletonSerializationProof</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例，但无法防止构造函数的反射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerSingletonSerializationProof</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingletonSerializationProof <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于非枚举单例模式，在面对序列化攻击时，必须实现 `readResolve()` 方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化期间：返回现有实例，而不是创建一个新的实例。</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33-完美版本的静态内部类单例"><a class="markdownIt-Anchor" href="#33-完美版本的静态内部类单例"></a> 3.3. 完美版本的“静态内部类单例”</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类单例：完美版本</span></span><br><span class="line"><span class="comment"> * 1. 利用静态内部类的特性提供懒加载和基于类加载机制的线程安全</span></span><br><span class="line"><span class="comment"> * 2. 尝试使用私有构造函数检查以防止反射攻击，但在所有情况下无法保证</span></span><br><span class="line"><span class="comment"> * 3. 使用定义的 serialVersionUID 和 readResolve() 来防止序列化攻击</span></span><br><span class="line"><span class="comment"> * 4. 重写 clone() 方法以防止克隆攻击</span></span><br><span class="line"><span class="comment"> * 5. 使用 final 类防止子类化，避免任何子类破坏单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StaticInnerSingletonPerfect</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确定义 `serialVersionUID` 可以避免潜在的不兼容问题。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类提供类的单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StaticInnerSingletonPerfect</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerSingletonPerfect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数：限制用户自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerSingletonPerfect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != InstanceHolder.instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This singleton instance already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingletonPerfect <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInnerSingletonPerfect.InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止序列化攻击</span></span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        <span class="comment">// 在反序列化期间：返回现有实例，而不是创建一个新的实例。</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// (1) 抛出异常以防止克隆</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;Cloning of this singleton instance is not allowed&quot;</span>);</span><br><span class="line">        <span class="comment">// (2) 或直接从克隆方法返回相同实例</span></span><br><span class="line">        <span class="comment">//return getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-枚举型单例"><a class="markdownIt-Anchor" href="#4-枚举型单例"></a> 4. 枚举型单例</h1>
<p>枚举型单例被认为是实现单例模式的最佳方式。它不仅利用了类加载机制来保证线程安全，还防止在反序列化过程中重建对象，并避免了反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. 枚举型单例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1. 实现非常简单，代码简洁。</span></span><br><span class="line"><span class="comment"> * 2. 天然线程安全，因为使用了类加载机制、私有构造函数和公共静态最终实例字段。</span></span><br><span class="line"><span class="comment"> * 3. 可以防止反射攻击，因为调用 `newInstance()` 时会抛出 IllegalArgumentException。</span></span><br><span class="line"><span class="comment"> * 4. 自带序列化功能，可以防止序列化攻击。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 1. 没有懒加载。</span></span><br><span class="line"><span class="comment"> * 2. 不能扩展其他类，因为枚举类隐式继承 `java.lang.Enum`。</span></span><br><span class="line"><span class="comment"> * 3. 不方便调试，因为一些关键代码是隐式自动生成的，比如私有构造函数、静态初始化块等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们分析一下枚举类的字节码。在编译 <code>EnumSingleton.java</code> 并通过 <code>javac -g EnumSingleton.java</code> 生成类文件后，执行 <code>javap -v -p EnumSingleton.class</code> 以生成字节码文件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">Classfile /DesignPattern-Lab/src/main/java/com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">26</span>/08/<span class="number">2024</span>; size <span class="number">1195</span> bytes</span><br><span class="line">  MD5 checksum 1e21098493b1502d48f3a4fba5884dcc</span><br><span class="line">  Compiled from <span class="string">&quot;EnumSingleton.java&quot;</span></span><br><span class="line"><span class="comment">// 枚举类隐式继承 `java.lang.Enum`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton&gt;</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_ENUM</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Fieldref           #<span class="number">4.</span>#<span class="number">34</span>         <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton.$VALUES:[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">   #<span class="number">2</span> = Methodref          #<span class="number">35.</span>#<span class="number">36</span>        <span class="comment">// &quot;[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&quot;.clone:()Ljava/lang/Object;</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">14</span>            <span class="comment">// &quot;[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&quot;</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">37</span>            <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">10.</span>#<span class="number">38</span>        <span class="comment">// java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">10.</span>#<span class="number">39</span>        <span class="comment">// java/lang/Enum.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">   #<span class="number">7</span> = String             #<span class="number">11</span>            <span class="comment">// instance</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">4.</span>#<span class="number">39</span>         <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">   #<span class="number">9</span> = Fieldref           #<span class="number">4.</span>#<span class="number">40</span>         <span class="comment">// com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton.instance:Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">41</span>            <span class="comment">// java/lang/Enum</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               instance</span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">  #<span class="number">13</span> = Utf8               $VALUES</span><br><span class="line">  #<span class="number">14</span> = Utf8               [Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">  #<span class="number">15</span> = Utf8               values</span><br><span class="line">  #<span class="number">16</span> = Utf8               ()[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">  #<span class="number">17</span> = Utf8               Code</span><br><span class="line">  #<span class="number">18</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               valueOf</span><br><span class="line">  #<span class="number">20</span> = Utf8               (Ljava/lang/String;)Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">  #<span class="number">21</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">22</span> = Utf8               name</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">25</span> = Utf8               (Ljava/lang/String;I)V</span><br><span class="line">  #<span class="number">26</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               Signature</span><br><span class="line">  #<span class="number">28</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">29</span> = Utf8               anyMethod</span><br><span class="line">  #<span class="number">30</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">31</span> = Utf8               Ljava/lang/Enum&lt;Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&gt;;</span><br><span class="line">  #<span class="number">32</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">33</span> = Utf8               EnumSingleton.java</span><br><span class="line">  #<span class="number">34</span> = NameAndType        #<span class="number">13</span>:#<span class="number">14</span>        <span class="comment">// $VALUES:[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">  #<span class="number">35</span> = Class              #<span class="number">14</span>            <span class="comment">// &quot;[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&quot;</span></span><br><span class="line">  #<span class="number">36</span> = NameAndType        #<span class="number">42</span>:#<span class="number">43</span>        <span class="comment">// clone:()Ljava/lang/Object;</span></span><br><span class="line">  #<span class="number">37</span> = Utf8               com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span><br><span class="line">  #<span class="number">38</span> = NameAndType        #<span class="number">19</span>:#<span class="number">44</span>        <span class="comment">// valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span></span><br><span class="line">  #<span class="number">39</span> = NameAndType        #<span class="number">24</span>:#<span class="number">25</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">  #<span class="number">40</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// instance:Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">  #<span class="number">41</span> = Utf8               java/lang/Enum</span><br><span class="line">  #<span class="number">42</span> = Utf8               clone</span><br><span class="line">  #<span class="number">43</span> = Utf8               ()Ljava/lang/Object;</span><br><span class="line">  #<span class="number">44</span> = Utf8               (Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `instance` 是一个 `public static final` 字段</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton instance;</span><br><span class="line">    descriptor: Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL, ACC_ENUM</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `private static final $VALUES` 字段保存所有枚举常量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton[] $VALUES;</span><br><span class="line">    descriptor: [Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `values()` 方法是由编译器自动生成的，用于返回定义的枚举常量数组</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton[] values();</span><br><span class="line">    descriptor: ()[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">1</span>                  <span class="comment">// Field $VALUES:[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">         <span class="number">3</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method &quot;[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&quot;.clone:()Ljava/lang/Object;</span></span><br><span class="line">         <span class="number">6</span>: checkcast     #<span class="number">3</span>                  <span class="comment">// class &quot;[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&quot;</span></span><br><span class="line">         <span class="number">9</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">4</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line">         <span class="number">2</span>: aload_0</span><br><span class="line">         <span class="number">3</span>: invokestatic  #<span class="number">5</span>                  <span class="comment">// Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span></span><br><span class="line">         <span class="number">6</span>: checkcast     #<span class="number">4</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line">         <span class="number">9</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  name   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自动生成的两个参数（String, int）的私有构造函数</span></span><br><span class="line">  <span class="keyword">private</span> com.sissilab.dp.ox1_creational.ox11_singleton.EnumSingleton();</span><br><span class="line">    descriptor: (Ljava/lang/String;I)V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="comment">// 将 `this` 引用加载到栈上（来自 slot 0）</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">// 将存储在局部变量 1 中的第一个参数（枚举常量的 `name`）加载到栈上</span></span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="comment">// 将存储在局部变量 2 中的第二个参数（枚举常量的 `ordinal`）加载到栈上</span></span><br><span class="line">         <span class="number">2</span>: iload_2</span><br><span class="line">         <span class="comment">// 调用超类构造函数 `java.lang.Enum (String name, int ordinal)`</span></span><br><span class="line">         <span class="number">3</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/Enum.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line">    Signature: #<span class="number">28</span>                          <span class="comment">// ()V</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态初始化块</span></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="comment">// 为由 #4 引用的类分配内存 -&gt; 将引用添加到操作数栈的顶部</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line">         <span class="comment">// dup：复制栈顶值 -&gt; 将复制的引用添加到操作数栈的顶部</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="comment">// ldc：将字符串实例加载到栈上（`String name`）</span></span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String instance</span></span><br><span class="line">         <span class="comment">// iconst_0：将整数常量 0 压入栈中（`int ordinal`）</span></span><br><span class="line">         <span class="number">6</span>: iconst_0</span><br><span class="line">         <span class="comment">// invokespecial：调用构造函数 EnumSingleton(String, int) 进行初始化</span></span><br><span class="line">         <span class="number">7</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">        <span class="comment">// putstatic：将创建的实例分配给 EnumSingleton 的静态字段 `instance`</span></span><br><span class="line">        <span class="number">10</span>: putstatic     #<span class="number">9</span>                  <span class="comment">// Field instance:Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">        <span class="comment">// iconst_1：将整数 1（要创建的数组的大小）压入栈中</span></span><br><span class="line">        <span class="number">13</span>: iconst_1</span><br><span class="line">        <span class="comment">// anewarray：创建一个新的 EnumSingleton 对象数组（大小为 1）</span></span><br><span class="line">        <span class="number">14</span>: anewarray     #<span class="number">4</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line">        <span class="comment">// dup：复制栈上的数组引用</span></span><br><span class="line">        <span class="number">17</span>: dup</span><br><span class="line">        <span class="comment">// iconst_0：将整数 0（数组的索引）压入栈中</span></span><br><span class="line">        <span class="number">18</span>: iconst_0</span><br><span class="line">        <span class="comment">// getstatic：获取静态字段 `instance`</span></span><br><span class="line">        <span class="number">19</span>: getstatic     #<span class="number">9</span>                  <span class="comment">// Field instance:Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">        <span class="comment">// aastore：将实例存储到数组的索引 0 处</span></span><br><span class="line">        <span class="number">22</span>: aastore</span><br><span class="line">        <span class="comment">// putstatic：将数组存储到静态字段 `$VALUES` 中（它按顺序保存所有枚举常量）</span></span><br><span class="line">        <span class="number">23</span>: putstatic     #<span class="number">1</span>                  <span class="comment">// Field $VALUES:[Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br><span class="line">        <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">31</span>                          <span class="comment">// Ljava/lang/Enum&lt;Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;&gt;;</span></span><br><span class="line">SourceFile: <span class="string">&quot;EnumSingleton.java&quot;</span></span><br></pre></td></tr></table></figure>
<p>实际上，初始化过程发生在静态初始化块（<code>static &#123;&#125;</code>，它会在类首次加载时执行），关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为由 #4 引用的类分配内存 -&gt; 将引用添加到操作数栈的顶部</span></span><br><span class="line"><span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class com/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup：复制栈顶值 -&gt; 将复制的引用添加到操作数栈的顶部</span></span><br><span class="line"><span class="number">3</span>: dup</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldc：将字符串实例加载到栈上（`String name`）</span></span><br><span class="line"><span class="number">4</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String instance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iconst_0：将整数常量 0 压入栈中（`int ordinal`）</span></span><br><span class="line"><span class="number">6</span>: iconst_0</span><br><span class="line"></span><br><span class="line"><span class="comment">// invokespecial：调用构造函数 EnumSingleton(String, int) 进行初始化</span></span><br><span class="line"><span class="number">7</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// putstatic：将创建的实例分配给 EnumSingleton 的静态字段 `instance`</span></span><br><span class="line"><span class="number">10</span>: putstatic     #<span class="number">9</span>                  <span class="comment">// Field instance:Lcom/sissilab/dp/ox1_creational/ox11_singleton/EnumSingleton;</span></span><br></pre></td></tr></table></figure>
<h2 id="41-对枚举型单例的反射攻击"><a class="markdownIt-Anchor" href="#41-对枚举型单例的反射攻击"></a> 4.1. 对“枚举型单例”的反射攻击</h2>
<p>当尝试通过反射获取枚举类的实例时，会抛出错误：<code>java.lang.IllegalArgumentException: Cannot reflectively create enum objects</code>。这有效地防止了反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReflectionAttackOnEnumSingleton</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 获取构造函数：只会自动生成一个带有两个参数的私有构造函数，如 `private EnumSingleton(String, int)`</span></span><br><span class="line">    Constructor&lt;EnumSingleton&gt; constructor = EnumSingleton.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="comment">// 设置构造函数的可访问性</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// reflectInstance: 通过构造函数创建实例</span></span><br><span class="line">    <span class="type">EnumSingleton</span> <span class="variable">reflectInstance</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;instance&quot;</span>, <span class="number">0</span>); <span class="comment">// java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// instance: 通过正常的 public static final `instance` 字段获取实例</span></span><br><span class="line">    <span class="type">EnumSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingleton.instance;</span><br><span class="line"></span><br><span class="line">    Assertions.assertSame(reflectInstance, instance); <span class="comment">// ×</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，错误是在 <code>public T newInstance(Object ... initargs)</code> 中抛出的。以下源代码表明有一个显式检查当前类是否为枚举类型，如果是，则会抛出 <code>IllegalArgumentException</code>。因此，枚举单例可以有效防止反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Constructor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Object ... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, <span class="literal">null</span>, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前类是枚举类型，则会抛出 `IllegalArgumentException`。</span></span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">        <span class="type">ConstructorAccessor</span> <span class="variable">ca</span> <span class="operator">=</span> constructorAccessor;   <span class="comment">// 读取 volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="literal">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">inst</span> <span class="operator">=</span> (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42-对枚举型单例的序列化攻击"><a class="markdownIt-Anchor" href="#42-对枚举型单例的序列化攻击"></a> 4.2. 对“枚举型单例”的序列化攻击</h2>
<p>每个枚举类隐式继承自 <code>java.lang.Enum</code> 抽象类，该类实现了 <code>java.io.Serializable</code>，这意味着枚举类可以支持序列化和反序列化。得益于其内置机制，枚举单例天然能够抵御序列化攻击，因为在反序列化过程中不会创建新的枚举常量实例。</p>
<p>让我们看看在反序列化源代码中枚举单例发生了什么。在 <code>readObject0(type, false)</code> 方法中，针对 <code>TC_ENUM</code> 的情况：–&gt; <code>readEnum(boolean unshared)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="type">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 仅处理作为枚举序列化的对象</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_ENUM) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 如果该类不是枚举，则会抛出 InvalidClassException。</span></span><br><span class="line">    <span class="keyword">if</span> (!desc.isEnum()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;non-enum class: &quot;</span> + desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">enumHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : <span class="literal">null</span>);</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="literal">null</span>) &#123;</span><br><span class="line">        handles.markException(enumHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取枚举常量的名称，例如 `instance`（每个常量名称在枚举中必须是唯一的）。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> readString(<span class="literal">false</span>);</span><br><span class="line">    Enum&lt;?&gt; result = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 使用枚举类（例如 `EnumSingleton`）和常量名称（例如 `instance`）查找常量</span></span><br><span class="line">            <span class="comment">// 这是关键部分，无论枚举序列化和反序列化多少次，都不会创建新的枚举实例。</span></span><br><span class="line">            Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br><span class="line">            result = en;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(</span><br><span class="line">                <span class="string">&quot;enum constant &quot;</span> + name + <span class="string">&quot; does not exist in &quot;</span> +</span><br><span class="line">                cl).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">            <span class="comment">// 在默认模式（共享模式）下，`unshared` 为 false。这意味着如果对象在序列化流中出现多次，所有指向该对象的引用都将指向同一个反序列化实例。</span></span><br><span class="line">            <span class="comment">// 将更新现有的句柄（`Object[] entries`），确保重用同一枚举实例，尤其是对于枚举单例。</span></span><br><span class="line">            handles.setObject(enumHandle, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handles.finish(enumHandle);</span><br><span class="line">    passHandle = enumHandle;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; T <span class="title function_">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 从内部映射 (`Map&lt;String, T&gt; enumConstantDirectory`) 中通过名称获取枚举常量</span></span><br><span class="line">    <span class="comment">// 在 `enumConstantDirectory()` 内部有一个预构建的映射，包含所有加载到内存中的枚举常量，确保每个枚举常量的唯一性。</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43-完美版本的枚举型单例"><a class="markdownIt-Anchor" href="#43-完美版本的枚举型单例"></a> 4.3. 完美版本的“枚举型单例”</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用此单例：</span></span><br><span class="line"><span class="comment"> * `EnumSingletonPerfect.instance.anyMethod();`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingletonPerfect</span> &#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问延迟加载的资源：</span></span><br><span class="line"><span class="comment">     * `EnumSingletonPerfect.instance.getExpensiveResource().useResource();`</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 使用静态内部类来实现重资源的延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHeavyResource</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HeavyResource</span> <span class="variable">RESOURCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeavyResource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeavyResource <span class="title function_">getExpensiveResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHeavyResource.RESOURCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个静态内部类代表一个重资源。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeavyResource</span> &#123;</span><br><span class="line">        HeavyResource() &#123;</span><br><span class="line">            <span class="comment">// 模拟耗费资源的初始化场景……需要大量时间来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">useResource</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Use this heavy resource...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-在源代码中的应用"><a class="markdownIt-Anchor" href="#5-在源代码中的应用"></a> 5. 在源代码中的应用</h1>
<h2 id="51-javalangruntime-饿汉式单例-静态常量"><a class="markdownIt-Anchor" href="#51-javalangruntime-饿汉式单例-静态常量"></a> 5.1. java.lang.Runtime (饿汉式单例 - 静态常量)</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式单例 - 静态常量：单例实例 `currentRuntime` 在类加载时初始化，确保实例提前创建并且是线程安全的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="comment">// 持有单例实例：在加载类时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数：防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制访问单例实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="52-orgquartzimplschedulerrepository-懒汉式单例-synchronized"><a class="markdownIt-Anchor" href="#52-orgquartzimplschedulerrepository-懒汉式单例-synchronized"></a> 5.2. org.quartz.impl.SchedulerRepository (懒汉式单例 - synchronized)</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scheduler scheduler = new StdSchedulerFactory().getScheduler(); -&gt; SchedulerRepository schedRep = SchedulerRepository.getInstance();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerRepository</span> &#123;</span><br><span class="line">    <span class="comment">// 持有单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SchedulerRepository inst;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数：防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SchedulerRepository</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制访问单例实例：使用静态同步方法以确保线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SchedulerRepository <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inst == <span class="literal">null</span>) &#123;</span><br><span class="line">            inst = <span class="keyword">new</span> <span class="title class_">SchedulerRepository</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-spring-orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistry-懒汉式单例-双重检查锁定-dcl"><a class="markdownIt-Anchor" href="#53-spring-orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistry-懒汉式单例-双重检查锁定-dcl"></a> 5.3. Spring - org.springframework.beans.factory.support.DefaultSingletonBeanRegistry (懒汉式单例 - 双重检查锁定 DCL)</h2>
<p>Spring 的单例模式：当在 Spring 应用程序上下文中定义一个 bean 时，如果没有明确指定作用域，Spring 会将其视为单例。这意味着 Spring 只会创建一个实例，该实例可以被所有类共享。通过在 Spring 中利用这种单例模式，我们可以享受到高效的内存管理、集中化的 bean 配置，以及在整个应用程序中共享和重用 bean 实例的好处。</p>
<p>在 Spring 中，加载单例的过程通常从 <code>org.springframework.beans.factory.BeanFactory</code> 的 <code>getBean()</code> 方法开始，其默认实现是抽象类 <code>org.springframework.beans.factory.support.AbstractBeanFactory</code>。各种 <code>getBean()</code> 方法最终调用 <code>AbstractBeanFactory</code> 的 <code>doGetBean()</code> 方法，例如 <code>org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取转换后的 bean 名称，以防名称包含非法字符</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">        Object bean;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查单例缓存以查找手动注册的单例</span></span><br><span class="line">        <span class="comment">// 通常情况下，它将在第一次请求 bean 时返回 null。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取给定 bean 实例的对象，要么是 bean 实例本身，要么是 FactoryBean 创建的对象。</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 创建 bean 实例</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 若该 bean 是单例，它将会进入重载的 `getSingleton()` 方法</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                                destroySingleton(beanName);</span><br><span class="line">                                <span class="keyword">throw</span> ex;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码 <code>Object sharedInstance = getSingleton(beanName);</code> 在 <code>getBean()</code> 方法中是 Spring 中单例模式（双重检查）的核心实现。<code>getSingleton()</code> 方法在 <code>AbstractBeanFactory</code> 的父类 <code>DefaultSingletonBeanRegistry</code> 中定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象缓存（完全初始化的单例 bean）：bean 名称 -&gt; bean 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 早期单例对象缓存（当前正在创建的单例 bean，部分创建）：bean 名称 -&gt; bean 实例</span></span><br><span class="line">    <span class="comment">// 这是解决循环依赖的关键。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例工厂缓存：bean 名称 -&gt; ObjectFactory</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 DCL 模式从缓存中获取 bean</span></span><br><span class="line">    <span class="comment">// `singletonObjects` -&gt; `earlySingletonObjects` -&gt; `singletonFactories` -&gt; 通过 `singletonFactory.getObject()` 创建单例 bean</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="comment">// (1) `singletonObjects`：检查缓存中是否包含 bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 在 `singletonObjects` 中找不到单例。&amp;&amp; 单例 bean 当前正在创建中。</span></span><br><span class="line">        <span class="comment">// isSingletonCurrentlyInCreation(beanName)：如果为真，则单例 bean 正在创建过程中但尚未完全初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123; <span class="comment">// 在 `singletonObjects` 映射上同步以确保线程安全</span></span><br><span class="line">                <span class="comment">// (2) `earlySingletonObjects`：此缓存保存正在创建的 bean。</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="comment">// 在 `earlySingletonObjects` 中找不到单例。&amp;&amp; `allowEarlyReference` 为真。</span></span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    <span class="comment">// 当某些方法需要提前初始化时，调用 `addSingleFactory()` 方法将相应的 `ObjectFactory` 初始化策略存储在 `singletonFactories` 映射中。</span></span><br><span class="line">                    <span class="comment">// (3) `singletonFactories`：通过 beanName 获取 ObjectFactory</span></span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建并获取 bean</span></span><br><span class="line">                        singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="comment">// 更新两个缓存：`earlySingletonObjects` 和 `singletonFactories` 互斥。</span></span><br><span class="line">                        <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，当第一次在 <code>doGetBean()</code> 中调用 <code>getSingleton()</code> 时，缓存中找不到对应的 bean 实例。然后，它进入 <code>if (mbd.isSingleton()) &#123; &#125;</code> 块，调用重载的 <code>getSingleton()</code> 方法。在此方法中，bean 被实例化，然后实例被缓存到 <code>singletonObjects</code> 映射中，从而允许在后续请求中直接返回单例 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="comment">// 由于创建过程涉及对 `singletonObjects` 的操作，因此需要加锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 1. 再次尝试从 `singletonObjects` 映射中获取 bean，并检查 bean 是否已加载。如果 bean 已加载，则直接返回。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 如果当前 BeanFactory 正在被销毁，则直接抛出异常，不允许创建单例 bean。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">                                                              <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                                                              <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 创建 bean 之前的一些准备工作：</span></span><br><span class="line">                <span class="comment">// beanName 被记录为当前正在加载（添加到 `singletonsCurrentlyInCreation` 缓存中）。</span></span><br><span class="line">                <span class="comment">// 如果 bean 已经在加载过程中，则抛出异常。</span></span><br><span class="line">                <span class="comment">// 这是为了解决循环引用问题。</span></span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Exception&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 通过回调机制获取 bean 实例。</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// 单例对象在此期间是否隐式出现 -&gt;</span></span><br><span class="line">                    <span class="comment">// 如果是，则继续使用它，因为该异常表明了状态。</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 5. 单例 bean 加载后的后处理步骤：</span></span><br><span class="line">                    <span class="comment">// 移除当前正在创建的 bean 的记录（从 `singletonsCurrentlyInCreation` 缓存中移除 beanName）。</span></span><br><span class="line">                    afterSingletonCreation(beanName); <span class="comment">// 从 singletonsCurrentlyInCreation 中移除该 beanName</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 6. 添加到 `singletonObjects` 缓存并从其他辅助缓存中移除（例如 `singletonFactories`、`earlySingletonObjects`）</span></span><br><span class="line">                    addSingleton(beanName, singletonObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="54-spring-orgspringframeworkcorereactiveadapterregistry-懒汉式单例-双重检查锁定-dcl"><a class="markdownIt-Anchor" href="#54-spring-orgspringframeworkcorereactiveadapterregistry-懒汉式单例-双重检查锁定-dcl"></a> 5.4. Spring - org.springframework.core.ReactiveAdapterRegistry (懒汉式单例 - 双重检查锁定 DCL)</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactiveAdapterRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 以防止重排序</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReactiveAdapterRegistry sharedInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双重检查锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReactiveAdapterRegistry <span class="title function_">getSharedInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReactiveAdapterRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> sharedInstance;</span><br><span class="line">        <span class="keyword">if</span> (registry == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ReactiveAdapterRegistry.class) &#123;</span><br><span class="line">                registry = sharedInstance;</span><br><span class="line">                <span class="keyword">if</span> (registry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    registry = <span class="keyword">new</span> <span class="title class_">ReactiveAdapterRegistry</span>();</span><br><span class="line">                    sharedInstance = registry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-spring-orgspringframeworkaopframeworkproxyfactorybean-懒汉式单例-synchronized"><a class="markdownIt-Anchor" href="#55-spring-orgspringframeworkaopframeworkproxyfactorybean-懒汉式单例-synchronized"></a> 5.5. Spring - org.springframework.aop.framework.ProxyFactoryBean (懒汉式单例 - synchronized)</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">ProxyCreatorSupport</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, BeanClassLoaderAware, BeanFactoryAware &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object singletonInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制对单例实例的访问：使用同步方法确保线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title function_">getSingletonInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.singletonInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSource = freshTargetSource();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">                <span class="comment">// 依赖 AOP 机制来告诉我们要代理哪些接口</span></span><br><span class="line">                Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">                <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FactoryBeanNotInitializedException</span>(<span class="string">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="built_in">this</span>.proxyClassLoader));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化共享的单例实例。</span></span><br><span class="line">            <span class="built_in">super</span>.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line">            <span class="comment">// 创建 AOP 动态代理 和 获取实例</span></span><br><span class="line">            <span class="built_in">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.singletonInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-tomcat-orgapachecatalinawebresourcestomcaturlstreamhandlerfactory-懒汉式单例-双重检查锁定-dcl"><a class="markdownIt-Anchor" href="#56-tomcat-orgapachecatalinawebresourcestomcaturlstreamhandlerfactory-懒汉式单例-双重检查锁定-dcl"></a> 5.6. Tomcat - org.apache.catalina.webresources.TomcatURLStreamHandlerFactory (懒汉式单例 - 双重检查锁定 DCL)</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatURLStreamHandlerFactory</span> <span class="keyword">implements</span> <span class="title class_">URLStreamHandlerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持有单例实例：添加 volatile 来防止指定重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">TomcatURLStreamHandlerFactory</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TomcatURLStreamHandlerFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        getInstanceInternal(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 双重检查锁定 DCL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TomcatURLStreamHandlerFactory <span class="title function_">getInstanceInternal</span><span class="params">(<span class="type">boolean</span> register)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var1</span> <span class="operator">=</span> TomcatURLStreamHandlerFactory.class;</span><br><span class="line">            <span class="keyword">synchronized</span>(TomcatURLStreamHandlerFactory.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">TomcatURLStreamHandlerFactory</span>(register);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://java-design-patterns.com/patterns/singleton/">Singleton Pattern in Java: Implementing Global Access Points in Java Applications | Java Design Patterns (java-design-patterns.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程-单例模式</a></li>
</ul>

      </div>
      
        <div class="prev-or-next">

          <div class="post-foot-prev">
            
              <a href="/zh-CN/design-pattern/factory-method-pattern/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>

          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2024-10-09
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">&nbsp;/
                      <a href="/zh-CN/categories/23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23 种设计模式">
                        23 种设计模式
                      </a>
                    </span>
                    
                    <span class="span--category">&nbsp;/
                      <a href="/zh-CN/categories/23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="1. 创建型模式">
                        1. 创建型模式
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="标签"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/zh-CN/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">
                        #设计模式
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/zh-CN/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式">
                        #创建型模式
                      </a>
                    </span>
                    
                  </span>
              
          </div>

          <div class="post-foot-next" >
            
              <a href="/zh-CN/design-pattern/design-pattern-overview/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>

        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E6%A6%82%E8%BF%B0"><span class="toc-text"> 0. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B"><span class="toc-text"> 1. 懒汉式单例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-text"> 1.1. 懒汉式单例 - 线程不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-synchronized"><span class="toc-text"> 1.2. 懒汉式单例 - synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%BB%B6%E8%BF%9F%E9%94%81"><span class="toc-text"> 1.3. 懒汉式单例 - 延迟锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%97%A0-volatile"><span class="toc-text"> 1.4. 懒汉式单例 - 双重检查锁定（无 volatile）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9Adcl"><span class="toc-text"> 1.5. 懒汉单例 - 双重检查锁定（DCL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#151-%E5%AF%B9%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-text"> 1.5.1. 对“懒汉单例 - 双重检查锁定”的反射攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E5%AF%B9%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text"> 1.5.2. 对“懒汉单例 - 双重检查锁定”的序列化攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-%E5%AE%8C%E7%BE%8E%E7%89%88%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A"><span class="toc-text"> 1.5.3. 完美版的“懒汉单例 - 双重检查锁定”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B"><span class="toc-text"> 2. 饿汉式单例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-text"> 2.1. 饿汉式单例 - 静态常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-text"> 2.1.1. 对“饿汉式单例 - 静态常量”的反射攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text"> 2.1.2. 对“饿汉式单例 - 静态常量”的序列化攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-%E5%AE%8C%E7%BE%8E%E7%89%88%E7%9A%84%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-text"> 2.1.3. 完美版的“饿汉式单例 - 静态常量”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-text"> 2.2. 饿汉式单例 - 静态块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-text"> 2.2.1. 对“饿汉式单例 - 静态块”的反射攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-%E5%AF%B9%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text"> 2.2.2. 对“饿汉式单例 - 静态块”的序列化攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-text"> 2.2.3. 完美版本的“饿汉式单例 - 静态块”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B"><span class="toc-text"> 3. 静态内部类单例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%AF%B9%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-text"> 3.1. 对“静态内部类单例”的反射攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%AF%B9%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text"> 3.2. 对“静态内部类单例”的序列化攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B"><span class="toc-text"> 3.3. 完美版本的“静态内部类单例”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B"><span class="toc-text"> 4. 枚举型单例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%AF%B9%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B%E7%9A%84%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-text"> 4.1. 对“枚举型单例”的反射攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%AF%B9%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB"><span class="toc-text"> 4.2. 对“枚举型单例”的序列化攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%AE%8C%E7%BE%8E%E7%89%88%E6%9C%AC%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%9E%8B%E5%8D%95%E4%BE%8B"><span class="toc-text"> 4.3. 完美版本的“枚举型单例”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%9C%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text"> 5. 在源代码中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-javalangruntime-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-text"> 5.1. java.lang.Runtime (饿汉式单例 - 静态常量)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-orgquartzimplschedulerrepository-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-synchronized"><span class="toc-text"> 5.2. org.quartz.impl.SchedulerRepository (懒汉式单例 - synchronized)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-spring-orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistry-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A-dcl"><span class="toc-text"> 5.3. Spring - org.springframework.beans.factory.support.DefaultSingletonBeanRegistry (懒汉式单例 - 双重检查锁定 DCL)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-spring-orgspringframeworkcorereactiveadapterregistry-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A-dcl"><span class="toc-text"> 5.4. Spring - org.springframework.core.ReactiveAdapterRegistry (懒汉式单例 - 双重检查锁定 DCL)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-spring-orgspringframeworkaopframeworkproxyfactorybean-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-synchronized"><span class="toc-text"> 5.5. Spring - org.springframework.aop.framework.ProxyFactoryBean (懒汉式单例 - synchronized)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-tomcat-orgapachecatalinawebresourcestomcaturlstreamhandlerfactory-%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A-dcl"><span class="toc-text"> 5.6. Tomcat - org.apache.catalina.webresources.TomcatURLStreamHandlerFactory (懒汉式单例 - 双重检查锁定 DCL)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#references"><span class="toc-text"> References</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/sissilab">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:xiangru.au@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/sissilab/hexo-theme-arch">Copyright © 2024 Arch</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/sissilab/hexo-theme-arch">Theme by Arch | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
      var lang = document.getElementById('xr-lang')?.value || '';
      var contextPath = document.getElementById('xr-context-path')?.value;
      var path = (contextPath && contextPath.endsWith('/') ? contextPath : contextPath + '/') + lang + "/search.xml";
      searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + %E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F + '&url=' + https%3A%2F%2Fsissilab.github.io%2Fzh-CN%2Fdesign-pattern%2Fsingleton-pattern%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://sissilab.github.io/zh-CN/design-pattern/singleton-pattern/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>




        <div class="switchlang-icon tools-bar-item" title="Switch a language">
  <a href="javascript: void(0)" id="switchlang">
    <i class="icon-lang-switcher">
      <svg t="1670338371149" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1377" width="16" height="16"><path d="M890.688 576h-124.672c-6.2912 100.928-27.264 192.7296-58.5216 266.5792 95.36-56.512 164.16-153.1072 183.1936-266.5792z m0-128c-19.0336-113.472-87.8336-210.0672-183.1936-266.5792 31.2512 73.856 52.2304 165.6576 58.528 266.5792h124.672zM133.312 448h124.672c6.2912-100.928 27.264-192.7296 58.5216-266.5792C221.1456 237.9328 152.3456 334.528 133.312 448z m0 128c19.0336 113.472 87.8336 210.0672 183.1936 266.5792-31.2512-73.856-52.2304-165.6576-58.528-266.5792H133.312z m504.416 0h-251.456c6.6944 93.6 27.8848 178.176 59.2 240.7936 16.0448 32.1088 33.4656 55.6416 49.5488 69.248 5.5488 4.6912 10.2336 7.6032 13.8688 9.088 1.7024 0.704 2.528 0.8704 3.1104 0.8704 0.576 0 1.408-0.1664 3.1104-0.864 3.6352-1.4912 8.32-4.4032 13.8688-9.0944 16.0832-13.6064 33.504-37.1392 49.5552-69.248 31.3088-62.6176 52.4992-147.1936 59.2-240.7936z m0-128c-6.6944-93.6-27.8848-178.176-59.2-240.7936-16.0448-32.1088-33.4656-55.6416-49.5488-69.248-5.5488-4.6912-10.2336-7.6032-13.8688-9.088-1.7024-0.704-2.528-0.8704-3.1104-0.8704-0.576 0-1.408 0.1664-3.1104 0.864-3.6352 1.4912-8.32 4.4032-13.8688 9.0944-16.0832 13.6064-33.504 37.1392-49.5552 69.248-31.3088 62.6176-52.4992 147.1936-59.2 240.7936h251.4624zM512 1024c-282.7712 0-512-229.2288-512-512S229.2288 0 512 0s512 229.2288 512 512-229.2288 512-512 512z" p-id="1378" fill="#666666"></path></svg>
    </i>
  </a>

  

  <div class="switchlang-content hidden">
    
        <a class="lang-item" href="/en/design-pattern/singleton-pattern/" title="en">
          English
        </a>
    
        <a class="lang-item" href="/zh-CN/design-pattern/singleton-pattern/" title="zh-CN">
          简体中文
        </a>
    
  </div>
</div>


<script src="/js/switchlang.js"></script>


      </div>
    </div>
  </body>
</html>
